/**
 * Charts Module
 * Handles all chart rendering and interactions
 */

// ============================================================================
// CUSTOM HTML TOOLTIP HANDLER
// ============================================================================

/**
 * Custom HTML tooltip handler for Chart.js (matches timeline tooltip styling)
 */
function getOrCreateTooltip(chart) {
    let tooltipEl = chart.canvas.parentNode.querySelector('div.chartjs-tooltip');

    if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.className = 'chartjs-tooltip';
        tooltipEl.style.cssText = `
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
        `;
        chart.canvas.parentNode.appendChild(tooltipEl);
    }

    return tooltipEl;
}

function externalTooltipHandler(context) {
    const { chart, tooltip } = context;
    const tooltipEl = getOrCreateTooltip(chart);

    // Hide if no tooltip
    if (tooltip.opacity === 0) {
        tooltipEl.style.opacity = 0;
        return;
    }

    // Set HTML content
    if (tooltip.body) {
        const titleLines = tooltip.title || [];
        const bodyLines = tooltip.body.map(b => b.lines);
        const colors = tooltip.labelColors[0];

        let innerHtml = '';

        // Title with color indicator (like timeline)
        if (titleLines.length > 0) {
            const color = colors.backgroundColor;
            innerHtml += `
                <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                    <div style="width: 12px; height: 12px; background: ${color}; border-radius: 2px; flex-shrink: 0;"></div>
                    <span style="font-weight: 600;">${titleLines[0]}</span>
                </div>
            `;
        }

        // Body lines (time and count)
        bodyLines.forEach((body, i) => {
            const lines = Array.isArray(body) ? body : [body];
            lines.forEach((line, j) => {
                const color = j === 0 ? '#ccc' : '#aaa';
                const fontSize = j === 0 ? '1em' : '0.9em';
                innerHtml += `<div style="color: ${color}; font-size: ${fontSize}; margin-bottom: ${j === lines.length - 1 ? '0' : '4px'};">${line}</div>`;
            });
        });

        tooltipEl.innerHTML = innerHtml;
    }

    const { offsetLeft: positionX, offsetTop: positionY } = chart.canvas;

    // Display, position, and set styles for font
    tooltipEl.style.opacity = 1;
    tooltipEl.style.left = positionX + tooltip.caretX + 10 + 'px';
    tooltipEl.style.top = positionY + tooltip.caretY - 40 + 'px';
}

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================

/**
 * Default color palette for pie/doughnut charts (used as fallback)
 * Each chart can specify its own custom colors via options.customColors
 */
const PIE_CHART_COLORS = [
    '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
    '#9966FF', '#FF9F40', '#E7E9ED', '#8E5EA2',
    '#3cba9f', '#e8c3b9', '#c45850', '#95d5b2',
    '#ffd6a5', '#caffbf', '#fdffb6'
];

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Destroy existing chart instance if it exists
 * @param {string} canvasId - ID of the canvas element
 */
function destroyChart(canvasId) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    const existingChart = Chart.getChart(canvasId) || ctx.chart;
    if (existingChart) {
        existingChart.destroy();
    }
}

/**
 * Scroll element into view smoothly
 * @param {HTMLElement} element - Element to scroll to
 */
function scrollToElement(element) {
    setTimeout(() => {
        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 100);
}

// ============================================================================
// FORMATTERS
// ============================================================================

/**
 * Create a tooltip formatter for time-based data
 * @param {Array} dataArray - Array of data objects for context
 * @returns {Function} Tooltip formatter function
 */
function createTimeTooltipFormatter(dataArray = null) {
    return (context) => {
        const label = context.label || '';
        const value = parseFloat(context.parsed);
        const total = context.dataset.data.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
        const percentage = ((value / total) * 100).toFixed(1);
        return label + ': ' + formatTime(value) + ' (' + percentage + '%)';
    };
}

/**
 * Create a data label formatter for time-based data
 * @param {number} threshold - Minimum percentage to show label (default: 5)
 * @returns {Function} Data label formatter function
 */
function createTimeLabelFormatter(threshold = 5) {
    return (value, ctx) => {
        const total = ctx.dataset.data.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
        const percentage = ((value / total) * 100);
        if (percentage > threshold) {
            return formatTime(parseFloat(value));
        }
        return '';
    };
}

/**
 * Create a tooltip formatter for folder data
 * @param {Array} folders - Array of folder objects
 * @returns {Function} Tooltip formatter function
 */
function createFolderTooltipFormatter(folders) {
    return (context) => {
        const folder = folders[context.dataIndex];
        return [
            `Path: ${folder.folder}`,
            `Time: ${formatTime(folder.total_time_ms / 1000)}`,
            `Assets: ${folder.asset_count}`
        ];
    };
}

/**
 * Create a tooltip formatter for importer data
 * @param {Array} importers - Array of importer objects
 * @returns {Function} Tooltip formatter function
 */
function createImporterTooltipFormatter(importers) {
    return (context) => {
        const importer = importers[context.dataIndex];
        return [
            `Total: ${formatTime(importer.total_time / 1000)}`,
            `Count: ${importer.count} assets`,
            `Avg: ${formatTime(importer.avg_time / 1000)}`
        ];
    };
}

// ============================================================================
// CONFIGURATION BUILDERS
// ============================================================================

/**
 * Build Chart.js configuration for pie/doughnut charts
 * @param {Object} options - Configuration options
 * @returns {Object} Chart.js configuration object
 */
function buildPieChartConfig(options) {
    const {
        labels,
        data,
        colors,
        isDoughnut = false,
        disableAnimation = false,
        legendPosition = 'right',
        legendFontSize = 11,
        tooltipFormatter,
        dataLabelFormatter,
        onClick = null
    } = options;

    // Respect a data label threshold supplied in options.
    // For doughnut/wheel charts default to a higher threshold to avoid crowded inner labels.
    const dataLabelThreshold = options.dataLabelThreshold !== undefined ? options.dataLabelThreshold : (isDoughnut ? 7 : 5);

    return {
        type: isDoughnut ? 'doughnut' : 'pie',
        data: {
            labels: labels,
            datasets: [{
                data: data,
                backgroundColor: colors,
                borderWidth: 0
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: disableAnimation ? false : undefined,
            plugins: {
                legend: {
                    position: legendPosition,
                    labels: {
                        font: { size: legendFontSize }
                    }
                },
                tooltip: {
                    enabled: false,  // Disable default tooltip
                    external: externalTooltipHandler,
                    callbacks: {
                        title: (context) => {
                            return context[0].label || '';
                        },
                        label: tooltipFormatter || createTimeTooltipFormatter()
                    }
                },
                datalabels: (function() {
                    // Ensure threshold is respected even when callers pass a custom dataLabelFormatter.
                    const baseFormatter = dataLabelFormatter || createTimeLabelFormatter(dataLabelThreshold);
                    const threshold = dataLabelThreshold;

                    return {
                        formatter: (value, ctx) => {
                            const total = ctx.dataset.data.reduce((a, b) => parseFloat(a) + parseFloat(b), 0) || 1;
                            const percentage = ((value / total) * 100);
                            if (percentage > threshold) {
                                // Preserve original formatter signature where possible
                                try {
                                    return baseFormatter.length === 2 ? baseFormatter(value, ctx) : baseFormatter(value);
                                } catch (e) {
                                    // Fallback: return raw value if custom formatter fails
                                    return value;
                                }
                            }
                            return '';
                        },
                        color: '#333',
                        font: {
                            weight: 'bold',
                            size: 14
                        }
                    };
                })()
            },
            onClick: onClick
        }
    };
}

/**
 * Build Chart.js configuration for horizontal bar charts
 * @param {Object} options - Configuration options
 * @returns {Object} Chart.js configuration object
 */
function buildBarChartConfig(options) {
    const {
        labels,
        data,
        color = '#667eea',
        tooltipFormatter,
        dataLabelFormatter,
        onClick = null,
        disableAnimation = false
    } = options;

    return {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Total Time',
                data: data,
                backgroundColor: color
            }]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            animation: disableAnimation ? false : undefined,
            plugins: {
                legend: { display: false },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.9)',
                    titleColor: '#fff',
                    titleFont: { size: 13, weight: '600' },
                    bodyColor: '#ccc',
                    bodyFont: { size: 12 },
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1,
                    padding: 12,
                    displayColors: false,
                    callbacks: {
                        label: tooltipFormatter
                    }
                },
                datalabels: {
                    anchor: 'end',
                    align: 'end',
                    formatter: (value) => formatTime(parseFloat(value)),
                    color: '#fff',
                    font: {
                        weight: 'bold',
                        size: 12
                    }
                }
            },
            onClick: onClick,
            scales: {
                x: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Total Import Time'
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: {
                        autoSkip: false
                    }
                }
            }
        }
    };
}

/**
 * Build Chart.js configuration for histogram with normal distribution overlay
 * @param {Object} options - Configuration options
 * @returns {Object} Chart.js configuration object
 */
function buildHistogramConfig(options) {
    const {
        bins,
        normalCurve,
        mean,
        stdDev,
        onClick,
        onHover
    } = options;

    const maxCount = Math.max(...bins.map(b => b.count), 1);
    const interactionHeight = maxCount * 1.2;

    return {
        type: 'bar',
        data: {
            labels: bins.map(b => formatTime(b.center)),
            datasets: [
                {
                    // Invisible interaction layer for easier clicking
                    label: '',
                    data: bins.map(() => interactionHeight),
                    backgroundColor: 'rgba(0, 0, 0, 0.01)',
                    borderColor: 'rgba(0, 0, 0, 0.01)',
                    borderWidth: 0,
                    order: 3,
                    datalabels: { display: false }
                },
                {
                    label: 'Asset Count',
                    data: bins.map(b => b.count),
                    backgroundColor: 'rgba(102, 126, 234, 0.7)',
                    borderColor: 'rgba(102, 126, 234, 1)',
                    borderWidth: 1,
                    order: 2
                },
                {
                    label: 'Normal Distribution',
                    data: normalCurve,
                    type: 'line',
                    borderColor: '#28a745',
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHitRadius: 0,
                    fill: false,
                    tension: 0.4,
                    order: 1,
                    datalabels: { display: false }
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Import Time (seconds)'
                    },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45,
                        callback: function (value, index) {
                            const step = Math.max(1, Math.floor(bins.length / 10));
                            return index % step === 0 ? formatTime(bins[index].center) : '';
                        }
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Number of Assets'
                    },
                    beginAtZero: true
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        filter: function (item, chart) {
                            // Only show visible histogram bars in legend
                            return item.datasetIndex === 1;
                        }
                    }
                },
                datalabels: {
                    display: function (context) {
                        // Only show labels on visible histogram bars
                        return context.datasetIndex === 1;
                    }
                },
                tooltip: {
                    displayColors: false,
                    callbacks: {
                        title: function (context) {
                            if (context[0].datasetIndex === 0 || context[0].datasetIndex === 1) {
                                const bin = bins[context[0].dataIndex];
                                return `${formatTime(bin.start)} - ${formatTime(bin.end)}`;
                            }
                            return '';
                        },
                        label: function (context) {
                            if (context.datasetIndex === 0 || context.datasetIndex === 1) {
                                const bin = bins[context.dataIndex];
                                return `${bin.count} assets in this range`;
                            }
                            return null;
                        },
                        filter: function (tooltipItem) {
                            return tooltipItem.datasetIndex === 0 || tooltipItem.datasetIndex === 1;
                        }
                    }
                }
            },
            onClick: onClick,
            onHover: onHover
        }
    };
}

// ============================================================================
// DATA PROCESSORS
// ============================================================================

/**
 * Process standard deviation data for histogram visualization
 * @param {Array} assets - Array of asset objects
 * @returns {Object} Processed data including stats, bins, and normal curve
 */
function processStdDevData(assets) {
    // Convert to seconds and calculate statistics
    const times = assets.map(asset => asset.import_time_ms / 1000);
    const mean = times.reduce((sum, time) => sum + time, 0) / times.length;
    const variance = times.reduce((sum, time) => sum + Math.pow(time - mean, 2), 0) / times.length;
    const stdDev = Math.sqrt(variance);
    const totalTime = times.reduce((sum, time) => sum + time, 0);

    // Create histogram bins
    const minTime = Math.min(...times);
    const maxTime = Math.max(...times);
    const binCount = Math.min(30, Math.max(10, Math.floor(Math.sqrt(assets.length))));
    const binWidth = (maxTime - minTime) / binCount || 0.001;

    const bins = Array(binCount).fill(0).map((_, i) => {
        const binStart = minTime + (i * binWidth);
        const binEnd = i === binCount - 1 ? maxTime + 0.001 : minTime + ((i + 1) * binWidth);
        return {
            start: binStart,
            end: binEnd,
            center: (binStart + binEnd) / 2,
            count: 0,
            assets: []
        };
    });

    // Assign assets to bins
    assets.forEach(asset => {
        const timeSeconds = asset.import_time_ms / 1000;
        const binIndex = Math.min(
            Math.floor((timeSeconds - minTime) / binWidth),
            binCount - 1
        );
        bins[binIndex].count++;
        bins[binIndex].assets.push(asset);
    });

    // Calculate normal distribution curve
    const normalCurve = bins.map(bin => {
        const x = bin.center;
        const z = (x - mean) / stdDev;
        const pdf = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);
        return pdf * assets.length * binWidth;
    });

    return {
        stats: {
            count: assets.length,
            totalTime: totalTime,
            mean: mean,
            stdDev: stdDev
        },
        bins: bins,
        normalCurve: normalCurve
    };
}

/**
 * Process folder data for chart display
 * @param {Array} folders - Array of folder objects
 * @returns {Object} Processed data with labels and values
 */
function processFolderData(folders) {
    const topFolders = folders.slice(0, 6);
    return {
        labels: topFolders.map(f => f.folder.split('/').slice(-2).join('/')),
        data: topFolders.map(f => (f.total_time_ms / 1000).toFixed(2)),
        folders: topFolders
    };
}

/**
 * Process importer data for chart display
 * @param {Array} importers - Array of importer objects
 * @returns {Object} Processed data with labels and values
 */
function processImporterData(importers) {
    const topImporters = importers.slice(0, 10);
    return {
        labels: topImporters.map(i => i.importer_type || 'Unknown'),
        data: topImporters.map(i => (i.total_time / 1000).toFixed(2)),
        importers: topImporters
    };
}

/**
 * Process category data for chart display
 * @param {Array} categories - Array of category objects
 * @returns {Object} Processed data with labels and values
 */
function processCategoryData(categories) {
    const topCategories = categories.slice(0, 15);
    return {
        labels: topCategories.map(c => c.asset_category || 'Unknown'),
        data: topCategories.map(c => (c.total_time / 1000).toFixed(2)),
        categories: topCategories
    };
}

/**
 * Process operations data for chart display
 * @param {Array} operations - Array of operation objects
 * @returns {Object} Processed data with labels and values
 */
function processOperationsData(operations) {
    const labels = [];
    const values = [];

    operations.forEach(op => {
        if (op.total_time_ms > 0) {
            labels.push(op.type);
            values.push((op.total_time_ms / 1000).toFixed(2));
        }
    });

    return { labels, values, operations };
}

// ============================================================================
// HTML GENERATORS
// ============================================================================

/**
 * Generate stat cards HTML
 * @param {Object} stats - Statistics object
 * @param {number} percentageOfLoad - Percentage of total load time
 * @returns {string} HTML string for stat cards
 */
function generateStatCards(stats, percentageOfLoad) {
    return `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <div class="stat-card" style="margin: 0;">
                <div class="stat-label">Asset Count</div>
                <div class="stat-value">${stats.count.toLocaleString()}</div>
            </div>
            <div class="stat-card" style="margin: 0;">
                <div class="stat-label">Total Time</div>
                <div class="stat-value">${formatTime(stats.totalTime)}</div>
            </div>
            <div class="stat-card" style="margin: 0;">
                <div class="stat-label">% of Full Load Time</div>
                <div class="stat-value">${percentageOfLoad}${percentageOfLoad !== 'N/A' ? '%' : ''}</div>
            </div>
            <div class="stat-card" style="margin: 0;">
                <div class="stat-label">Mean</div>
                <div class="stat-value">${formatTime(stats.mean)}</div>
            </div>
            <div class="stat-card" style="margin: 0;">
                <div class="stat-label">Std Dev</div>
                <div class="stat-value">${formatTime(stats.stdDev)}</div>
            </div>
        </div>
    `;
}

/**
 * Generate standard deviation view HTML
 * @param {string} assetType - Type of asset
 * @param {Object} stats - Statistics object
 * @param {number} percentageOfLoad - Percentage of total load time
 * @returns {string} HTML string for std dev view
 */
function generateStdDevViewHTML(assetType, stats, percentageOfLoad) {
    return `
        <div class="table-container">
            <h2>ðŸ“Š Standard Deviation Analysis: ${assetType}</h2>
            ${generateStatCards(stats, percentageOfLoad)}
            <p style="margin-bottom: 15px; color: #666;">
                ðŸ’¡ Distribution of import times with theoretical normal curve. <strong>Click</strong> any bar to see assets in that time range.
            </p>
            <div style="position: relative; height: 500px; margin-bottom: 20px;">
                <canvas id="stdDevChart"></canvas>
            </div>
            <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 20px; height: 12px; background: #667eea;"></div>
                    <span style="font-size: 0.9em;">Actual Distribution (Histogram)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 20px; height: 2px; background: #28a745;"></div>
                    <span style="font-size: 0.9em;">Theoretical Normal Curve (Mean: ${formatTime(stats.mean)}, Std Dev: ${formatTime(stats.stdDev)})</span>
                </div>
            </div>
        </div>
    `;
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

/**
 * Handle click on standard deviation histogram
 * @param {Event} event - Click event
 * @param {Array} elements - Clicked chart elements
 * @param {Array} bins - Histogram bins
 * @param {string} assetType - Type of asset
 */
function handleStdDevChartClick(event, elements, bins, assetType) {
    const chart = window.stdDevChartInstance;

    // Get the x position of the click
    const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
    const xValue = chart.scales.x.getValueForPixel(canvasPosition.x);

    let binIndex = -1;

    // Try to get binIndex from element if available
    if (elements && elements.length > 0) {
        const barElement = elements.find(el => (el.datasetIndex === 0 || el.datasetIndex === 1) && el.index !== undefined);
        if (barElement && barElement.index !== undefined) {
            binIndex = barElement.index;
        }
    }

    // If we couldn't get it from element, find by time value
    if (binIndex < 0) {
        binIndex = bins.findIndex(bin => {
            return xValue >= bin.start && xValue <= bin.end;
        });
    }

    if (binIndex >= 0 && binIndex < bins.length) {
        const bin = bins[binIndex];
        if (bin && bin.assets && bin.assets.length > 0) {
            displayAssetsTable(bin.assets, `${assetType} Assets (${formatTime(bin.start)} - ${formatTime(bin.end)})`);
        }
    }
}

/**
 * Handle hover on charts to show pointer cursor
 * @param {Event} event - Hover event
 * @param {Array} elements - Hovered chart elements
 */
function handleChartHover(event, elements) {
    const isClickable = elements.length > 0 && (elements[0].datasetIndex === 0 || elements[0].datasetIndex === 1);
    event.native.target.style.cursor = isClickable ? 'pointer' : 'default';
}

/**
 * Handle click on importer chart
 * @param {Event} event - Click event
 * @param {Array} elements - Clicked chart elements
 * @param {Array} importers - Array of importer objects
 */
function handleImporterChartClick(event, elements, importers) {
    if (elements.length > 0) {
        const index = elements[0].index;
        const importer = importers[index];
        loadImporterDetail(importer.importer_type);
    }
}

/**
 * Handle click on category chart
 * @param {Event} event - Click event
 * @param {Array} elements - Clicked chart elements
 */
function handleCategoryChartClick(event, elements) {
    if (elements.length > 0) {
        const index = elements[0].index;
        const chart = window.chartInstances.categoryChart;
        if (chart && chart.data && chart.data.labels && chart.data.labels[index]) {
            const category = chart.data.labels[index];
            loadCategoryDetail(category);
        }
    }
}

/**
 * Handle click on pipeline breakdown chart
 * @param {Event} event - Click event
 * @param {Array} elements - Clicked chart elements
 */
function handlePipelineChartClick(event, elements) {
    if (elements.length > 0) {
        const index = elements[0].index;
        const chart = window.chartInstances.pipelineBreakdownChart;
        if (chart && chart.data && chart.data.labels && chart.data.labels[index]) {
            const label = chart.data.labels[index];
            loadOperationsByType(label);
        }
    }
}

// ============================================================================
// SHARED CHART CREATION
// ============================================================================

/**
 * Shared function to create pie or doughnut charts
 * @param {string} canvasId - ID of the canvas element
 * @param {Array} labels - Array of label strings
 * @param {Array} data - Array of data values
 * @param {Object} options - Configuration options
 * @returns {Chart|null} Chart instance or null if canvas not found
 */
function createPieChart(canvasId, labels, data, options = {}) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) {
        console.error(`Canvas element not found: ${canvasId}`);
        return null;
    }

    // Destroy existing chart
    destroyChart(canvasId);

    // Use custom colors if provided, otherwise use standard palette
    const colors = options.customColors || PIE_CHART_COLORS;
    const backgroundColor = labels.map((_, i) => colors[i % colors.length]);

    // Build configuration
    const config = buildPieChartConfig({
        labels: labels,
        data: data,
        colors: backgroundColor,
        isDoughnut: options.isDoughnut || false,
        disableAnimation: options.disableAnimation || false,
        legendPosition: options.legendPosition || 'right',
        legendFontSize: options.legendFontSize || 11,
        tooltipFormatter: options.tooltipFormatter,
        dataLabelFormatter: options.dataLabelFormatter || createTimeLabelFormatter(options.dataLabelThreshold || 5),
        dataLabelThreshold: options.dataLabelThreshold || 5,
        onClick: options.onClick || null
    });

    // Create chart
    const chart = new Chart(ctx, config);

    // Store chart instance
    ctx.chart = chart;
    window.chartInstances = window.chartInstances || {};
    window.chartInstances[canvasId] = chart;

    // Show chart (hide spinner)
    if (typeof showChart === 'function') {
        showChart(canvasId);
    }

    return chart;
}

// ============================================================================
// CHART LOADING FUNCTIONS
// ============================================================================

/**
 * Load assets by type (displays table)
 * @param {string} assetType - Type of asset to load
 */
async function loadAssetsByType(assetType) {
    try {
        await displayAssetsTableProgressive(assetType, `${assetType} Assets`);
    } catch (error) {
        showError('Failed to load type detail: ' + error.message);
    }
}

/**
 * Load standard deviation view for an asset type
 * @param {string} assetType - Type of asset to analyze
 */
async function loadStdDevView(assetType) {
    try {
        // 1. Fetch data
        const assets = await window.apiClient.getAssetsByType(assetType);

        if (!assets || assets.length === 0) {
            showError('No assets found for this type');
            return;
        }

        // 2. Process data
        const processedData = processStdDevData(assets);

        // 3. Calculate percentage of load time
        const summary = await window.apiClient.getSummary();
        const projectLoadTime = summary.project_load_time || 0;
        const percentageOfLoad = projectLoadTime > 0
            ? ((processedData.stats.totalTime / projectLoadTime) * 100).toFixed(1)
            : 'N/A';

        // 4. Store view state for back button
        setStdDevViewState({
            assetType: assetType,
            assets: assets,
            mean: processedData.stats.mean,
            stdDev: processedData.stats.stdDev,
            totalTime: processedData.stats.totalTime,
            percentageOfLoad: percentageOfLoad
        });

        // 5. Generate and display HTML
        const tablesDiv = document.getElementById('tables');
        tablesDiv.innerHTML = generateStdDevViewHTML(assetType, processedData.stats, percentageOfLoad);

        // 6. Build chart configuration
        const chartConfig = buildHistogramConfig({
            bins: processedData.bins,
            normalCurve: processedData.normalCurve,
            mean: processedData.stats.mean,
            stdDev: processedData.stats.stdDev,
            onClick: (event, elements) => handleStdDevChartClick(event, elements, processedData.bins, assetType),
            onHover: (event, elements) => handleChartHover(event, elements)
        });

        // 7. Render chart
        const ctx = document.getElementById('stdDevChart').getContext('2d');
        destroyChart('stdDevChart');
        window.stdDevBins = processedData.bins;
        window.stdDevChartInstance = new Chart(ctx, chartConfig);

        // 8. Scroll to view
        scrollToElement(tablesDiv);

    } catch (error) {
        showError('Failed to load standard deviation view: ' + error.message);
        console.error('Error loading std dev view:', error);
    }
}

/**
 * Load folders chart (top 6 folders by import time)
 * @param {boolean} disableAnimation - Whether to disable chart animation
 */
async function loadFoldersChart(disableAnimation = false) {
    const chart = new BaseChart('foldersChart', {
        disableAnimation,
        emptyMessage: 'No folder data available',
        errorMessage: 'Failed to load chart'
    });

    await chart.load(
        () => window.apiClient.getFolderAnalysis(),
        (folders) => processFolderData(folders),
        (processedData) => ({
            type: 'pie',
            isDoughnut: true,
            labels: processedData.labels,
            data: processedData.data,
            legendPosition: 'right',
            legendFontSize: 10,
            dataLabelThreshold: 0,
            colors: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'],
            tooltipFormatter: createFolderTooltipFormatter(processedData.folders),
            dataLabelFormatter: (value) => formatTime(parseFloat(value))
        })
    );
}

/**
 * Load importer chart (top 10 importers by time)
 * @param {Array} importerData - Array of importer objects
 * @param {boolean} disableAnimation - Whether to disable chart animation
 */
function loadImporterChart(importerData, disableAnimation = false) {
    const chart = new BaseChart('importerChart', {
        disableAnimation,
        emptyMessage: 'No importer data available',
        errorMessage: 'Failed to load chart'
    });

    // BaseChart.load expects an async data fetcher, but we already have the data
    // So we wrap it in a Promise.resolve
    chart.load(
        () => Promise.resolve(importerData),
        (data) => processImporterData(data),
        (processedData) => ({
            type: 'bar',
            labels: processedData.labels,
            data: processedData.data,
            color: '#667eea',
            tooltipFormatter: createImporterTooltipFormatter(processedData.importers),
            onClick: (event, elements) => handleImporterChartClick(event, elements, processedData.importers)
        })
    );
}

/**
 * Load category chart (top 15 categories by time)
 * @param {Array} categoryData - Array of category objects
 * @param {boolean} disableAnimation - Whether to disable animation
 */
function loadCategoryChart(categoryData, disableAnimation = false) {
    const chart = new BaseChart('categoryChart', {
        disableAnimation,
        emptyMessage: 'No category data available',
        errorMessage: 'Failed to load chart'
    });

    chart.load(
        () => Promise.resolve(categoryData),
        (data) => processCategoryData(data),
        (processedData) => ({
            type: 'pie',
            labels: processedData.labels,
            data: processedData.data,
            legendPosition: 'right',
            legendFontSize: 11,
            dataLabelThreshold: 5,
            colors: [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
                '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52BE80',
                '#EC7063', '#5DADE2', '#F1948A', '#82E0AA', '#F4D03F'
            ],
            tooltipFormatter: (context) => {
                const value = parseFloat(context.parsed);
                const total = context.dataset.data.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
                const percentage = ((value / total) * 100).toFixed(1);
                const count = processedData.categories[context.dataIndex]?.count || 0;
                return [
                    formatTime(value) + ' (' + percentage + '%)',
                    count + ' assets'
                ];
            },
            onClick: (event, elements) => handleCategoryChartClick(event, elements)
        })
    );
}

/**
 * Load pipeline breakdown chart (operations by type)
 */
async function loadPipelineBreakdown(disableAnimation = false) {
    const chart = new BaseChart('pipelineBreakdownChart', {
        disableAnimation,
        emptyMessage: 'No operations found',
        errorMessage: 'Failed to load chart'
    });

    await chart.load(
        () => window.apiClient.getOperationsBreakdown(),
        (operations) => processOperationsData(operations),
        (processedData) => ({
            type: 'pie',
            labels: processedData.labels,
            data: processedData.values,
            legendPosition: 'right',
            dataLabelThreshold: 0,
            colors: [
                '#9966FF', '#FF9F40', '#4CAF50', '#2196F3',
                '#F44336', '#9C27B0', '#00BCD4', '#FFC107',
                '#795548', '#607D8B'
            ],
            dataLabelFormatter: (value) => formatTime(parseFloat(value)),
            onClick: (event, elements) => handlePipelineChartClick(event, elements)
        })
    );
}

// ============================================================================
// EXPORTS
// ============================================================================

// Export to global scope for use in overview.js and other modules
window.createPieChart = createPieChart;
window.PIE_CHART_COLORS = PIE_CHART_COLORS;
window.loadFoldersChart = loadFoldersChart;
window.loadImporterChart = loadImporterChart;
window.loadCategoryChart = loadCategoryChart;
