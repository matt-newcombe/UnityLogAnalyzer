/**
 * Timeline Module
 * Handles project load timeline visualization
 */

/**
 * Display timeline visualization
 * @param {Object} data - Timeline data (unused, fetches from API)
 */
function displayTimeline(data) {
    const container = document.getElementById('timeline-container');
    if (!container) {
        console.error('[Timeline] timeline-container element not found');
        return;
    }

    const startTime = performance.now();

    // Fetch both timeline data and summary to get category breakdown for color matching
    const timelineStart = performance.now();
    Promise.all([
        window.apiClient.getTimeline(),
        window.apiClient.getSummary()
    ])
        .then(([timelineData, summary]) => {
            const apiTime = performance.now() - timelineStart;

            // Extract category data from summary (same as used by category chart)
            const categoryData = summary.by_category || [];

            const renderStart = performance.now();
            try {
                renderTimelineVisualization(container, timelineData, categoryData);
            } catch (renderError) {
                console.error('[Timeline] Error during rendering:', renderError);
                container.innerHTML = '<p style="color: #ff4444;">Error rendering timeline: ' + renderError.message + '</p>';
                return;
            }
            const renderTime = performance.now() - renderStart;
            const totalTime = performance.now() - startTime;

        })
        .catch(error => {
            const totalTime = performance.now() - startTime;
            console.error(`[Timeline] Failed to load timeline after ${totalTime.toFixed(2)}ms:`, error);
            if (container) {
                container.innerHTML = '<p style="color: #ff4444;">Failed to load timeline data: ' + error.message + '</p>';
            }
        });
}

/**
 * Render the timeline visualization with segments
 * @param {HTMLElement} container - Container element
 * @param {Object} timelineData - Timeline data from API
 * @param {Array} categoryData - Category breakdown data from API (to match chart colors)
 */
function renderTimelineVisualization(container, timelineData, categoryData = []) {
    if (!timelineData || !timelineData.segments) {
        console.error('Invalid timeline data:', timelineData);
        container.innerHTML = '<p style="color: #ff4444;">Invalid timeline data</p>';
        return;
    }

    const totalTime = timelineData.total_time_ms / 1000; // Convert to seconds
    const segments = timelineData.segments || [];
    const summary = timelineData.summary || {};

    // Category colors - must match the category chart exactly
    // Top colors are more distinct to avoid similar bluey-purple shades
    const categoryChartColors = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
        '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52BE80',
        '#EC7063', '#5DADE2', '#F1948A', '#82E0AA', '#F4D03F'
    ];

    // Use category data from API to ensure exact match with chart
    // Category data is already sorted by total_time (descending) - same as chart
    const categoryColors = {};
    if (categoryData && categoryData.length > 0) {
        // Use the exact same order and colors as the category chart
        categoryData.forEach((category, index) => {
            const categoryName = category.asset_category || category.category || 'Other';
            categoryColors[categoryName] = categoryChartColors[index % categoryChartColors.length];
        });
    } else {
        // Fallback: calculate from segments if category data not available
        const categoryTimes = {};
        segments.filter(s => s.phase === 'AssetImports' && s.category).forEach(s => {
            if (!categoryTimes[s.category]) {
                categoryTimes[s.category] = 0;
            }
            categoryTimes[s.category] += s.duration_ms;
        });

        const uniqueCategories = Object.keys(categoryTimes).sort((a, b) => {
            return categoryTimes[b] - categoryTimes[a];  // Descending order
        });

        uniqueCategories.forEach((category, index) => {
            categoryColors[category] = categoryChartColors[index % categoryChartColors.length];
        });
    }

    // Get unique categories for legend (use categoryData order if available, otherwise from segments)
    const uniqueCategories = categoryData && categoryData.length > 0
        ? categoryData.map(c => c.asset_category || c.category || 'Other')
        : Object.keys(categoryColors);

    // Format timestamp to H:M:S format
    const formatTimestamp = (timestamp) => {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
    };

    // Create timeline HTML with filter toggles
    let html = `
        <div style="margin-bottom: 10px; display:flex; flex-direction: column; gap:8px;">
            <div style="display:flex; justify-content:space-between; align-items: center;">
                <h3 style="font-size: 1.8em; color: #667eea; margin: 0;">
                    Log Timeline
                </h3>
                <div style="display:flex; gap:12px; align-items:center;">
                    <label style="font-size:0.9em; color:#555;"><input id="toggle-imports" type="checkbox" checked style="margin-right:6px;">Imports</label>
                    <label style="font-size:0.9em; color:#555;"><input id="toggle-operations" type="checkbox" checked style="margin-right:6px;">Operations</label>
                    <label style="font-size:0.9em; color:#555;"><input id="toggle-cache" type="checkbox" checked style="margin-right:6px;">Cache Server</label>
                </div>
            </div>
            <p style="color: #666; font-size: 0.9em; margin: 0;">
                Total time: ${formatTime(totalTime)} | Asset imports: ${formatTime(summary.asset_import_time_ms / 1000)} | Total imports: ${summary.total_imports || 0}
            </p>
        </div>
        
        <div id="main-timeline-lane" style="position: relative; width: 100%; height: 80px; background: #f5f5f5; border-radius: 8px; overflow: visible; margin-top: 50px; margin-bottom: 15px;">
    `;

    // Render all segments (using timestamps for accurate positioning)
    // Normalize all positions and widths relative to total_time_ms
    // Formula: width = (duration_ms / total_time_ms) * 100%
    // Formula: position = (start_time / total_time_ms) * 100%
    const totalTimeMs = timelineData.total_time_ms;

    if (!totalTimeMs || totalTimeMs <= 0) {
        console.error('Invalid total_time_ms:', totalTimeMs);
        container.innerHTML = `
            <div style="padding: 20px; text-align: center;">
                <p style="color: #ff4444; font-size: 1.1em; margin-bottom: 10px;">
                    No timeline data available
                </p>
                <p style="color: #666; font-size: 0.9em;">
                    The log file may not contain any import or operation data, or the data may still be processing.
                </p>
            </div>
        `;
        return;
    }

    segments.forEach((segment, index) => {
        // Ensure segment has valid values
        const durationMs = segment.duration_ms || 0;
        const startTime = segment.start_time || 0;

        // Calculate width as proportion of total time: duration_ms / total_time_ms
        const widthPercent = Math.max(0, Math.min(100, (durationMs / totalTimeMs) * 100));
        // Calculate position as proportion of total time: start_time / total_time_ms
        const leftPercent = Math.max(0, Math.min(100, (startTime / totalTimeMs) * 100));

        // Use category color for AssetImports segments
        let segmentColor = segment.color;
        if (segment.phase === 'AssetImports' && segment.category) {
            segmentColor = categoryColors[segment.category] || segment.color;
        }

        // Special styling for Pipeline Refresh operations
        // These are non-blocking container operations that overlap other operations
        const isPipelineRefresh = segment.operation_type === 'Asset Pipeline Refresh';

        let segmentOpacity = '1';
        let segmentBorder = 'none';  // Remove borders from inner elements to avoid conflicts
        let segmentZIndex = '1';
        let segmentHeight = '100%';
        let segmentTop = '0';
        let wrapperBorderTop = 'none';
        let wrapperBorderBottom = 'none';
        let wrapperBorderLeft = 'none';
        let wrapperBorderRight = 'none';

        if (isPipelineRefresh) {
            const borderWidth = '2px';  // Reduced from 3px for less visual weight
            const borderStyle = `${borderWidth} dashed rgba(59, 130, 246, 0.8)`;
            segmentOpacity = '0.25';  // Semi-transparent background

            // Only show borders if the segment is wide enough to be visible
            // Skip borders for very thin operations (less than 0.5% of timeline width)
            if (widthPercent >= 0.5) {
                wrapperBorderTop = borderStyle;
                wrapperBorderBottom = borderStyle;
                wrapperBorderLeft = borderStyle;
                wrapperBorderRight = borderStyle;
            }

            segmentZIndex = '0';  // Behind other operations
            segmentColor = '#3b82f6';  // Blue color for container
        } else {
            // Shrink non-pipeline items slightly to fit inside pipeline container
            // This creates visual nesting effect
            segmentHeight = 'calc(100% - 6px)';
            segmentTop = '3px';
        }

        const lineNumber = segment.line_number || null;
        const descriptionEscaped = (segment.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
        html += `
            <div class="timeline-segment-wrapper" 
                 style="position: absolute; 
                        left: ${leftPercent}%; 
                        width: ${widthPercent}%; 
                        height: 100%; 
                        cursor: pointer;
                        z-index: ${segmentZIndex};
                        border-top: ${wrapperBorderTop};
                        border-bottom: ${wrapperBorderBottom};
                        border-left: ${wrapperBorderLeft};
                        border-right: ${wrapperBorderRight};"
                 data-phase="${segment.phase}"
                 data-description="${descriptionEscaped}"
                 data-duration="${segment.duration_ms}"
                 data-line-number="${lineNumber || ''}"
                 data-category="${segment.category || ''}"
                 onmouseover="showTimelineTooltip(event, this)"
                 onmouseout="hideTimelineTooltip()"
                 onclick="navigateToLogLine(${lineNumber || 'null'})">
                <div class="timeline-segment-visual" 
                     style="position: absolute;
                            top: ${segmentTop};
                            left: 0;
                            width: 100%;
                            height: ${segmentHeight};
                            background: ${segmentColor}; 
                            opacity: ${segmentOpacity};
                            transition: transform 0.15s ease-out;
                            border-right: ${segmentBorder};">
                </div>
            </div>
        `;
    });

    // Add timestamp labels at start and end of timeline if available
    if (timelineData.first_timestamp && timelineData.last_timestamp) {
        const firstTime = formatTimestamp(timelineData.first_timestamp);
        const lastTime = formatTimestamp(timelineData.last_timestamp);

        // Start timestamp (left side)
        html += `
            <div style="position: absolute; 
                        left: 0; 
                        top: -32px; 
                        font-size: 0.85em; 
                        font-weight: 500;
                        color: #495057; 
                        white-space: nowrap;
                        background: white;
                        padding: 6px 12px;
                        border-radius: 8px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                        letter-spacing: 0.3px;">
                ${firstTime}
            </div>
        `;

        // End timestamp (right side)
        html += `
            <div style="position: absolute; 
                        right: 0; 
                        top: -32px; 
                        font-size: 0.85em; 
                        font-weight: 500;
                        color: #495057; 
                        white-space: nowrap;
                        background: white;
                        padding: 6px 12px;
                        border-radius: 8px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                        letter-spacing: 0.3px;
                        text-align: right;">
                ${lastTime}
            </div>
        `;
    }

    // Worker Thread Lanes - get data first
    const workerThreads = timelineData.worker_threads || {};
    const workerIds = Object.keys(workerThreads).sort((a, b) => parseInt(a) - parseInt(b));

    // Add worker phase overlays to main timeline
    // Collect all worker phases from all threads
    const allWorkerPhases = [];
    workerIds.forEach(workerId => {
        const workerData = workerThreads[workerId];
        const phaseBlocks = workerData.phase_blocks || [];
        allWorkerPhases.push(...phaseBlocks);
    });

    // Render phase overlays on main timeline (before closing the main timeline div)
    allWorkerPhases.forEach(phaseBlock => {
        const widthPercent = Math.max(0, Math.min(100, (phaseBlock.duration_ms / totalTimeMs) * 100));
        const leftPercent = Math.max(0, Math.min(100, (phaseBlock.start_time / totalTimeMs) * 100));

        html += `
            <div class="timeline-phase-overlay" 
                 style="position: absolute; 
                        left: ${leftPercent}%; 
                        width: ${widthPercent}%; 
                        height: 100%; 
                        background: rgba(255, 152, 0, 0.15);
                        border: 2px solid rgba(255, 152, 0, 0.6);
                        border-radius: 4px;
                        pointer-events: auto;
                        cursor: help;
                        z-index: 5;"
                 data-phase="Worker Wait"
                 data-description="Mainthread waiting for worker thread completion"
                 data-duration="${phaseBlock.duration_ms}"
                 onmouseover="showTimelineTooltip(event, this)"
                 onmouseout="hideTimelineTooltip()">
            </div>
        `;
    });

    html += `</div>`;

    if (workerIds.length > 0) {
        html += `
            <div style="margin-top: 30px;">
        `;

        workerIds.forEach(workerId => {
            const workerData = workerThreads[workerId];
            const workerSegments = workerData.segments || [];

            html += `
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                        <span style="font-size: 0.9em; font-weight: 500; color: #495057; min-width: 80px;">
                            Worker ${workerId}
                        </span>
                        <span style="font-size: 0.8em; color: #999;">
                            ${workerData.total_operations} operations
                        </span>
                    </div>
                    <div id="worker-lane-${workerId}" style="position: relative; width: 100%; height: 40px; background: #f5f5f5; border-radius: 6px; overflow: visible;">
            `;

            // Render worker segments
            workerSegments.forEach(segment => {
                const widthPercent = Math.max(0, Math.min(100, (segment.duration_ms / totalTimeMs) * 100));
                const leftPercent = Math.max(0, Math.min(100, (segment.start_time / totalTimeMs) * 100));

                const lineNumber = segment.line_number || null;
                const descriptionEscaped = (segment.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                const operationCount = segment.operation_count || 1;

                html += `
                    <div class="timeline-segment-wrapper" 
                         style="position: absolute; 
                                left: ${leftPercent}%; 
                                width: ${widthPercent}%; 
                                height: 100%; 
                                cursor: pointer;"
                         data-phase="${segment.phase}"
                         data-description="${descriptionEscaped}"
                         data-duration="${segment.duration_ms}"
                         data-line-number="${lineNumber || ''}"
                         data-category="${segment.category || ''}"
                         data-worker-id="${workerId}"
                         data-operation-count="${operationCount}"
                         onmouseover="showTimelineTooltip(event, this)"
                         onmouseout="hideTimelineTooltip()"
                         onclick="navigateToLogLine(${lineNumber || 'null'})">
                        <div class="timeline-segment-visual" 
                             style="position: absolute;
                                    top: 0;
                                    left: 0;
                                    width: 100%;
                                    height: 100%;
                                    background: ${segment.color}; 
                                    opacity: 0.8;
                                    transition: transform 0.15s ease-out, opacity 0.15s ease-out;
                                    border-right: 1px solid rgba(0,0,0,0.1);">
                        </div>
                    </div>
                `;
            });



            html += `
                    </div>
                </div>
            `;
        });

        html += `</div>`;
    }

    // Legend - show top 10 categories
    html += `
        <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; margin-top: 15px;">
    `;

    const top10Categories = uniqueCategories.slice(0, 10);
    top10Categories.forEach(category => {
        const color = categoryColors[category];
        if (color) {
            html += `
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: ${color}; border-radius: 3px;"></div>
                    <span style="font-size: 0.9em;">${category}</span>
                </div>
            `;
        }
    });

    html += `</div>`;

    container.innerHTML = html;

    // Wire up timeline filter toggles
    try {
        const updateFilters = () => {
            const showImports = document.getElementById('toggle-imports')?.checked ?? true;
            const showOperations = document.getElementById('toggle-operations')?.checked ?? true;
            const showCache = document.getElementById('toggle-cache')?.checked ?? true;

            // All segment wrappers and overlays
            const wrappers = container.querySelectorAll('.timeline-segment-wrapper, .timeline-phase-overlay');
            wrappers.forEach(el => {
                const phase = (el.getAttribute('data-phase') || '').trim();

                const isImport = phase === 'AssetImports' || phase === 'WorkerImport';
                const isOperation = phase === 'Operation' || phase === 'CompileScripts';
                const isCache = phase === 'CacheServerDownload';

                if ((isImport && !showImports) || (isOperation && !showOperations) || (isCache && !showCache)) {
                    el.style.display = 'none';
                } else {
                    el.style.display = '';
                }
            });

            // Also hide worker lane containers if all their children are hidden (optional)
            const workerLanes = container.querySelectorAll('[id^="worker-lane-"]');
            workerLanes.forEach(lane => {
                const visibleChild = Array.from(lane.children).some(c => c.style.display !== 'none');
                lane.parentElement.style.display = visibleChild ? '' : 'none';
            });
        };

        ['toggle-imports', 'toggle-operations', 'toggle-cache'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.addEventListener('change', updateFilters);
        });

        // Apply initial filter state
        updateFilters();
    } catch (e) {
        console.warn('[Timeline] Failed to wire filter toggles:', e);
    }

    // Ensure tooltip exists in body
    let tooltip = document.getElementById('timeline-tooltip');
    if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'timeline-tooltip';
        tooltip.style.position = 'fixed'; // Use fixed for viewport positioning
        tooltip.style.background = 'rgba(0,0,0,0.9)';
        tooltip.style.color = 'white';
        tooltip.style.padding = '10px 15px';
        tooltip.style.borderRadius = '5px';
        tooltip.style.fontSize = '0.9em';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.zIndex = '10000'; // High z-index
        tooltip.style.display = 'none';
        tooltip.style.maxWidth = '300px';
        document.body.appendChild(tooltip);
    }

    // Draw connecting lines after render
    // Use setTimeout to ensure DOM is updated and layout is stable
    setTimeout(() => {
        drawConnectingLines(container, timelineData);
    }, 0);
}

/**
 * Draw connecting lines from Main Thread to Worker Threads
 * @param {HTMLElement} container - Main container
 * @param {Object} timelineData - Timeline data
 */
function drawConnectingLines(container, timelineData) {
    const mainLane = document.getElementById('main-timeline-lane');
    if (!mainLane) return;

    const totalTimeMs = timelineData.total_time_ms;
    const workerThreads = timelineData.worker_threads || {};
    const workerIds = Object.keys(workerThreads);

    // Create SVG overlay
    // We need it to cover the area from the bottom of main lane to the bottom of the last worker lane
    // But to be safe, let's make it cover the whole container relative to the main lane

    // Remove existing SVG if any
    const existingSvg = document.getElementById('timeline-connections-svg');
    if (existingSvg) existingSvg.remove();

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.id = 'timeline-connections-svg';
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '1';
    svg.style.overflow = 'visible'; // Allow drawing outside if needed

    // We'll append SVG to the container, but we need coordinates relative to the container
    container.style.position = 'relative';

    const mainRect = mainLane.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();

    // Y position of the bottom of the main lane, relative to container
    const mainBottomY = mainRect.bottom - containerRect.top;

    // X offset of the main lane relative to container (in case of padding/margin)
    const mainLeftX = mainRect.left - containerRect.left;
    const mainWidth = mainRect.width;

    workerIds.forEach(workerId => {
        const workerLane = document.getElementById(`worker-lane-${workerId}`);
        if (!workerLane) return;

        const workerRect = workerLane.getBoundingClientRect();
        const workerTopY = workerRect.top - containerRect.top;

        const phases = workerThreads[workerId].phase_blocks || [];
        phases.forEach(phase => {
            // Calculate X positions in pixels relative to main lane width
            const startRatio = phase.start_time / totalTimeMs;
            const endRatio = (phase.start_time + phase.duration_ms) / totalTimeMs;

            const startX = mainLeftX + (startRatio * mainWidth);
            const endX = mainLeftX + (endRatio * mainWidth);

            // Helper to create line
            const createLine = (xPos) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', xPos);
                line.setAttribute('y1', mainBottomY);
                line.setAttribute('x2', xPos);
                line.setAttribute('y2', workerTopY);
                line.setAttribute('stroke', '#999'); // Darker color
                line.setAttribute('stroke-width', '2'); // Thicker line
                line.setAttribute('stroke-dasharray', '4 4'); // Dashed line
                return line;
            };

            svg.appendChild(createLine(startX));
            svg.appendChild(createLine(endX));
        });
    });

    container.appendChild(svg);
}

/**
 * Show tooltip for timeline segment on hover
 * @param {Event} event - Mouse event
 * @param {HTMLElement} element - Timeline segment element
 */
function showTimelineTooltip(event, element) {
    try {
        const tooltip = document.getElementById('timeline-tooltip');
        if (!tooltip) return;

        const description = element.getAttribute('data-description') || '';
        const category = element.getAttribute('data-category');
        const phase = element.getAttribute('data-phase');
        const workerId = element.getAttribute('data-worker-id');

        // Get the segment color from the visual element (or use default for overlays)
        const visualElement = element.querySelector('.timeline-segment-visual');
        let segmentColor = '#999';
        if (visualElement) {
            segmentColor = window.getComputedStyle(visualElement).backgroundColor;
        } else if (element.classList.contains('timeline-phase-overlay')) {
            segmentColor = 'rgba(255, 152, 0, 0.6)'; // Orange for worker wait
        }

        // Parse description to extract time (format: "... (X.XXs)" or "... (Xm Ys)")
        // This shows wall time which is more important when present
        const timeMatch = description ? description.match(/\(([^)]+)\)$/) : null;
        const timeText = timeMatch ? timeMatch[1] : '';
        const descriptionWithoutTime = timeMatch && description ? description.substring(0, timeMatch.index).trim() : description;

        // Build tooltip HTML with structured format:
        // Line 1: Color indicator + Category/Phase
        // Line 2: Time
        // Line 3: Worker ID (if applicable)
        // Line 4: Other details (description without time)
        let tooltipHTML = '';

        // Line 1: Color indicator + Category/Phase
        const categoryLabel = category && category !== '' ? category : (phase || 'Other');
        tooltipHTML += `<div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
            <div style="width: 12px; height: 12px; background: ${segmentColor}; border-radius: 2px; flex-shrink: 0;"></div>
            <span style="font-weight: 600;">${categoryLabel}</span>
        </div>`;

        // Line 2: Time
        if (timeText) {
            tooltipHTML += `<div style="margin-bottom: 4px; color: #ccc;">${timeText}</div>`;
        }

        // Line 3: Worker ID (if applicable)
        if (workerId !== null && workerId !== undefined && workerId !== '') {
            tooltipHTML += `<div style="margin-bottom: 4px; color: #999; font-size: 0.85em;">Worker Thread ${workerId}</div>`;
        }

        // Line 4: Operation count (if grouped)
        const operationCount = element.getAttribute('data-operation-count');
        if (operationCount && parseInt(operationCount) > 1) {
            tooltipHTML += `<div style="margin-bottom: 4px; color: #aaa; font-size: 0.85em;">${operationCount} operations grouped</div>`;
        }

        // Line 5: Other details (description without time)
        if (descriptionWithoutTime) {
            tooltipHTML += `<div style="color: #aaa; font-size: 0.9em;">${descriptionWithoutTime}</div>`;
        }

        tooltip.innerHTML = tooltipHTML;
        tooltip.style.display = 'block';

        // Use clientX/Y for fixed positioning
        tooltip.style.left = (event.clientX + 15) + 'px';
        tooltip.style.top = (event.clientY + 15) + 'px';

        // Lift the visual element up by 25% (half of previous 50%)
        if (visualElement) {
            visualElement.style.transform = 'translateY(-25%)';
        }
    } catch (error) {
        console.error('[Timeline] Error showing tooltip:', error);
        // Don't break the timeline if tooltip fails
    }
}

/**
 * Hide timeline tooltip
 */
function hideTimelineTooltip() {
    const tooltip = document.getElementById('timeline-tooltip');
    if (tooltip) {
        tooltip.style.display = 'none';
    }

    // Reset all visual segments
    document.querySelectorAll('.timeline-segment-visual').forEach(seg => {
        seg.style.transform = 'translateY(0)';
    });
}

// Make function globally available
window.displayTimeline = displayTimeline;

