<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity Log Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <!-- Utility Scripts -->
    <script src="/static/js/dom-utils.js"></script>
    <script src="/static/js/api-client.js"></script>
    <script src="/static/js/chart-helpers.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f7;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-content {
            flex: 1;
        }
        
        .header-nav {
            display: flex;
            gap: 15px;
        }
        
        .nav-button {
            background: #667eea;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: background 0.2s;
        }
        
        .nav-button:hover {
            background: #5568d3;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            color: #666;
            font-size: 1.1em;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .stat-label {
            color: #888;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .stat-value {
            color: #333;
            font-size: 2.2em;
            font-weight: bold;
        }
        
        .stat-unit {
            color: #666;
            font-size: 0.6em;
            margin-left: 5px;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .chart-card h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .chart-container {
            position: relative;
            height: 350px;
            min-height: 350px;
        }
        
        /* Skeleton loaders */
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s ease-in-out infinite;
            border-radius: 8px;
        }
        
        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .skeleton-stat-card {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
        }
        
        .skeleton-stat-label {
            height: 14px;
            width: 60%;
            margin-bottom: 15px;
        }
        
        .skeleton-stat-value {
            height: 36px;
            width: 40%;
            margin-bottom: 10px;
        }
        
        .skeleton-chart {
            height: 350px;
            width: 100%;
        }
        
        .skeleton-table-row {
            height: 48px;
            margin-bottom: 8px;
        }
        
        .skeleton-timeline {
            height: 200px;
            width: 100%;
            margin-bottom: 20px;
        }
        
        /* Loading spinner for individual elements */
        .element-spinner {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            min-height: 200px;
            color: #667eea;
        }
        
        .element-spinner .loading-spinner {
            margin-right: 10px;
        }
        
        .table-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            table-layout: fixed; /* Force table to respect column widths */
        }
        
        th {
            background: #f8f9fa;
            color: #495057;
            padding: 12px 16px;
            text-align: left;
            font-weight: 500;
            font-size: 13px;
            border-bottom: 2px solid #dee2e6;
            position: sticky;
            white-space: nowrap;
            top: 0;
        }
        
        td {
            padding: 14px 16px;
            border-bottom: 1px solid #e8e8e8;
            vertical-align: middle;
            color: #333;
            line-height: 1.5;
        }
        
        tbody tr {
            cursor: pointer;
            box-sizing: border-box;
        }
        
        tbody tr:hover {
            background: #f8f9fa;
        }
        
        /* Better text truncation */
        .text-truncate {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .text-truncate-long {
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Monospace for codes/IDs */
        .mono {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.9em;
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        /* Badge styles */
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 500;
            background: #e3f2fd;
            color: #1976d2;
        }
        
        .badge-warning {
            background: #fff3e0;
            color: #f57c00;
        }
        
        .badge-success {
            background: #e8f5e9;
            color: #388e3c;
        }
        
        
        /* Context menu for right-click */
        .context-menu {
            position: fixed !important;
            background: white !important;
            border: 1px solid #ddd !important;
            border-radius: 4px !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
            padding: 4px 0 !important;
            z-index: 100000 !important;
            min-width: 150px !important;
            pointer-events: auto !important;
        }
        
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
        }
        
        .context-menu-item:hover {
            background: #f0f0f0;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #333;
            font-size: 1.5em;
        }
        
        /* Log Viewer Overlay */
        .log-viewer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .log-viewer-overlay.active {
            display: block;
            opacity: 1;
        }
        
        .log-viewer-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 80%;
            max-width: 1200px;
            height: 100vh;
            background: #1e1e1e;
            box-shadow: -5px 0 30px rgba(0,0,0,0.5);
            z-index: 10001;
            display: flex;
            flex-direction: column;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .log-viewer-panel.active {
            right: 0;
        }
        
        .log-viewer-header {
            background: #2d2d2d;
            padding: 20px 25px;
            border-bottom: 1px solid #3d3d3d;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .log-viewer-header h2 {
            color: white;
            margin: 0;
            font-size: 1.3em;
        }
        
        .log-viewer-close {
            background: #3d3d3d;
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .log-viewer-close:hover {
            background: #4d4d4d;
        }
        
        .log-viewer-controls {
            background: #2d2d2d;
            padding: 15px 25px;
            border-bottom: 1px solid #3d3d3d;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-shrink: 0;
        }
        
        .log-viewer-search {
            flex: 1;
            max-width: 400px;
        }
        
        .log-viewer-search input {
            width: 100%;
            padding: 8px 15px;
            border: 1px solid #3d3d3d;
            background: #1e1e1e;
            color: white;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .log-viewer-filters {
            display: flex;
            gap: 10px;
        }
        
        .log-viewer-filter-btn {
            padding: 8px 15px;
            border: 1px solid #3d3d3d;
            background: #2d2d2d;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .log-viewer-filter-btn:hover {
            background: #3d3d3d;
        }
        
        .log-viewer-filter-btn.active {
            background: #667eea;
            border-color: #667eea;
        }
        
        .log-viewer-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: #d4d4d4;
        }
        
        .log-viewer-line {
            padding: 2px 0;
            display: flex;
            border-left: 3px solid transparent;
            padding-left: 10px;
        }
        
        .log-viewer-line:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .log-viewer-line.highlighted {
            background: rgba(255, 235, 59, 0.2);
            border-left-color: #ffeb3b;
        }
        
        .log-viewer-line-number {
            color: #858585;
            min-width: 60px;
            text-align: right;
            user-select: none;
            padding-right: 15px;
        }
        
        .log-viewer-line-content {
            flex: 1;
            word-wrap: break-word;
        }
        
        .log-viewer-line.error {
            background: rgba(244, 135, 113, 0.15);  /* Subtle red tint */
            border-left-color: #f48771;
        }
        
        .log-viewer-line.error .log-viewer-line-content {
            color: #f48771;
        }
        
        .log-viewer-line.warning {
            background: rgba(220, 220, 170, 0.1);  /* Subtle yellow tint */
            border-left-color: #dcdcaa;
        }
        
        .log-viewer-line.warning .log-viewer-line-content {
            color: #dcdcaa;
        }
        
        .log-viewer-line.system .log-viewer-line-content {
            color: #4ec9b0;
        }
        
        .log-viewer-line.import .log-viewer-line-content {
            color: #9cdcfe;
        }
        
        .log-viewer-line.pipeline .log-viewer-line-content {
            color: #c586c0;
            font-weight: bold;
        }
        
        .log-viewer-stats {
            background: #2d2d2d;
            padding: 10px 25px;
            border-top: 1px solid #3d3d3d;
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #858585;
            flex-shrink: 0;
        }
        
        .log-viewer-loading {
            text-align: center;
            padding: 50px;
            color: #858585;
            font-size: 1.1em;
        }
        
        .indent-1 { padding-left: 30px; }
        .indent-2 { padding-left: 50px; }
        .indent-3 { padding-left: 70px; }
        .indent-4 { padding-left: 90px; }
        .indent-5 { padding-left: 110px; }
        
        .timestamp {
            color: #6a9955;
            margin-right: 10px;
        }
        
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #loading-progress {
            margin-top: 20px;
            font-size: 0.75em;
            color: #333;
            max-height: 400px;
            overflow-y: auto;
            text-align: left;
            background: rgba(0, 0, 0, 0.05);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            width: 100%;
            box-sizing: border-box;
        }
        
        .error:not(.log-viewer-line) {
            background: #ff4444;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .breadcrumb {
            margin-bottom: 20px;
            color: white;
            font-size: 1.1em;
        }
        
        .breadcrumb a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            margin-right: 10px;
            transition: background 0.2s;
        }
        
        .breadcrumb a:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .clickable {
            cursor: pointer;
        }
        
        .back-button {
            display: inline-block;
            background: white;
            color: #667eea;
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            margin-bottom: 20px;
            font-weight: 600;
            transition: transform 0.2s;
        }
        
        .back-button:hover {
            transform: translateX(-5px);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <h1><svg width="128" height="80" viewBox="0 0 120 30" style="vertical-align: middle; margin-right: 15px; display: inline-block;" xmlns="http://www.w3.org/2000/svg"><rect fill="#e4e4e4" x="0" y="0" width="120" height="30"/><rect fill="#2d2d30" x="8.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="14.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="20.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="26.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="32.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="38.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="44.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="50.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="56.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="62.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="68.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="74.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="80.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="86.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="92.5" y="7.5" width="3" height="15"/><rect fill="#2d2d30" x="98.5" y="7.5" width="3" height="15"/></svg> Unity Log Analyzer<span id="project-name" style="color: #667eea; font-size: 0.6em; margin-left: 15px;"></span><span id="unity-version" style="color: #999; font-size: 0.5em; margin-left: 10px;"></span></h1>
                <p class="subtitle">Interactive visualization of Unity Editor.log performance data</p>
                <p style="font-size: 0.85em; color: #999; margin-top: 5px;">Version: {{ version }}</p>
            </div>
            <div class="header-nav">
                <input type="file" id="log-file-input" accept=".log" style="display: none;" onchange="handleFileSelect(event)">
                <button class="nav-button" onclick="document.getElementById('log-file-input').click()" style="background: #4CAF50; border: none; cursor: pointer; height: 44px; padding: 0 16px;">üìÅ Parse Log File</button>
                <a href="/log-viewer" class="nav-button" style="height: 44px; padding: 0 16px; display: inline-flex; align-items: center;">üìÑ View Full Log</a>
            </div>
        </header>
        
        <div id="breadcrumb" class="breadcrumb"></div>
        
        <div id="loading" class="loading" style="display: none;">
            <span class="loading-spinner"></span>
            <span id="loading-text">Loading data</span>
            <div id="loading-progress"></div>
        </div>
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="stats" class="stats-grid" style="display: none;"></div>
        <div id="charts" class="charts-grid" style="display: none;"></div>
        <div id="tables"></div>
        
        <div id="slack-button-container" style="text-align: center; margin: 40px 0; padding: 20px;">
            <button class="nav-button" onclick="copySlackHeadlines()" style="background: #667eea; border: none; cursor: pointer; height: 44px; padding: 0 16px;" id="slack-copy-btn">üìã Copy Headlines for Slack</button>
        </div>
    </div>

    <script>
        // Register datalabels plugin globally
        Chart.register(ChartDataLabels);
        
        let currentLogId = 1; // Default to first log
        let currentView = 'overview';
        let stdDevViewState = null; // Store histogram view state for back button
        let currentFilter = null;
        
        // Helper function to format seconds into readable format
        function formatTime(seconds) {
            if (seconds >= 3600) {
                // Hours:Minutes format (omit seconds for readability)
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                return `${hours}h ${mins}m`;
            } else if (seconds >= 60) {
                // Minutes:Seconds format
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}m ${secs}s`;
            }
            return seconds.toFixed(2) + 's';
        }
        
        // Helper function to hide spinner and show chart
        function showChart(canvasId) {
            try {
                const canvas = document.getElementById(canvasId);
                if (!canvas) {
                    console.warn(`Canvas element not found: ${canvasId}`);
                    return;
                }
                const container = canvas.parentElement;
                if (!container) {
                    console.warn(`Container not found for canvas: ${canvasId}`);
                    return;
                }
                const spinner = container.querySelector('.element-spinner');
                if (spinner) spinner.style.display = 'none';
                if (canvas) canvas.style.display = 'block';
            } catch (error) {
                console.error(`Error showing chart ${canvasId}:`, error);
            }
        }
        
        // Make sure showChart is accessible globally
        window.showChart = showChart;
        
        // Initialize
        loadLogList();
        
        async function loadLogList() {
            try {
                const response = await fetch('/api/logs');
                const logs = await response.json();
                
                if (logs.length === 0) {
                    // Show empty state - user can upload a file
                    hideLoading();
                    showEmptyState();
                    return;
                }
                
                currentLogId = logs[0].id;
                updateProjectName(logs[0].project_name);
                loadOverview();
            } catch (error) {
                // Database might not exist yet - show empty state
                hideLoading();
                showEmptyState();
            }
        }
        
        function showEmptyState() {
            const statsDiv = document.getElementById('stats');
            const chartsDiv = document.getElementById('charts');
            statsDiv.style.display = 'none';
            chartsDiv.style.display = 'none';
            
            // Hide Slack copy button when no log is loaded
            const slackButtonContainer = document.getElementById('slack-button-container');
            if (slackButtonContainer) {
                slackButtonContainer.style.display = 'none';
            }
            
            chartsDiv.innerHTML = `
                <div class="chart-card" style="grid-column: 1 / -1; text-align: center; padding: 60px;">
                    <h2 style="color: #666; margin-bottom: 20px;">No Log File Parsed</h2>
                    <p style="color: #999; margin-bottom: 30px; font-size: 1.1em;">Click "Parse Log File" in the header to upload and analyze a Unity Editor.log file</p>
                    <button class="nav-button" onclick="document.getElementById('log-file-input').click()" style="background: #4CAF50; border: none; cursor: pointer; height: 44px; padding: 0 16px;">üìÅ Select Log File</button>
                </div>
            `;
        }
        
        function updateProjectName(projectName) {
            const projectNameEl = document.getElementById('project-name');
            if (projectNameEl && projectName) {
                projectNameEl.textContent = `- ${projectName}`;
            } else if (projectNameEl) {
                projectNameEl.textContent = '';
            }
        }
        
        function updateUnityVersion(unityVersion) {
            const unityVersionEl = document.getElementById('unity-version');
            if (unityVersionEl && unityVersion && unityVersion !== 'Unknown') {
                unityVersionEl.textContent = `(${unityVersion})`;
            } else if (unityVersionEl) {
                unityVersionEl.textContent = '';
            }
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Clear all visual elements
            document.getElementById('tables').innerHTML = '';
            document.getElementById('breadcrumb').innerHTML = '';
            document.getElementById('stats').innerHTML = '';
            document.getElementById('stats').style.display = 'none';
            document.getElementById('charts').innerHTML = '';
            document.getElementById('charts').style.display = 'none';
            
            // Hide Slack copy button
            const slackButtonContainer = document.getElementById('slack-button-container');
            if (slackButtonContainer) {
                slackButtonContainer.style.display = 'none';
            }
            
            // Show loading with progress
            showLoading('Parsing log file...');
            hideError();
            
            // Clear previous progress
            const progressDiv = document.getElementById('loading-progress');
            progressDiv.textContent = '';
            
            // Upload file and stream progress
            const formData = new FormData();
            formData.append('file', file);
            
            // Use fetch with streaming response
            fetch('/api/parse-log', {
                method: 'POST',
                body: formData
            })
            .then(async res => {
                if (!res.ok) {
                    const error = await res.json();
                    throw new Error(error.error || 'Failed to parse log file');
                }
                
                // Check if response is streaming (text/event-stream) or JSON
                const contentType = res.headers.get('content-type');
                if (contentType && contentType.includes('text/event-stream')) {
                    // Stream progress updates with performance optimizations
                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    // Use a buffer for messages to batch DOM updates
                    const messageBuffer = [];
                    const MAX_LINES = 500; // Limit displayed lines to prevent DOM bloat
                    let updateScheduled = false;
                    
                    // Efficient update function that batches DOM writes
                    function updateProgress() {
                        if (messageBuffer.length === 0) return;
                        
                        // Get current content
                        let currentText = progressDiv.textContent;
                        const currentLines = currentText.split('\n').filter(l => l.trim());
                        
                        // Add new messages
                        messageBuffer.forEach(msg => {
                            if (msg.trim()) {
                                currentLines.push(msg.trim());
                            }
                        });
                        
                        // Keep only recent lines to prevent DOM bloat
                        if (currentLines.length > MAX_LINES) {
                            currentLines.splice(0, currentLines.length - MAX_LINES);
                        }
                        
                        // Update DOM in one operation
                        progressDiv.textContent = currentLines.join('\n');
                        progressDiv.scrollTop = progressDiv.scrollHeight;
                        
                        // Clear buffer
                        messageBuffer.length = 0;
                        updateScheduled = false;
                    }
                    
                    // Throttled update using requestAnimationFrame
                    function scheduleUpdate() {
                        if (!updateScheduled) {
                            updateScheduled = true;
                            requestAnimationFrame(updateProgress);
                        }
                    }
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            // Final update
                            updateProgress();
                            break;
                        }
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); // Keep incomplete line in buffer
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    if (data.message) {
                                        messageBuffer.push(data.message);
                                        scheduleUpdate(); // Schedule batched update
                                    }
                                    if (data.complete) {
                                        // Final update before completion
                                        updateProgress();
                                        if (data.log_id) {
                                            currentLogId = data.log_id;
                                            // Add 1 second delay before reloading
                                            setTimeout(() => location.reload(), 1000);
                                        } else {
                                            showError('Parsing completed but no log ID returned');
                                            hideLoading();
                                        }
                                        return;
                                    }
                                    if (data.error) {
                                        updateProgress(); // Show any pending messages
                                        showError('Failed to parse log file: ' + data.error);
                                        hideLoading();
                                        // Show Slack button again on error
                                        const slackButtonContainer = document.getElementById('slack-button-container');
                                        if (slackButtonContainer) {
                                            slackButtonContainer.style.display = 'block';
                                        }
                                        return;
                                    }
                                } catch (e) {
                                    // Skip malformed JSON
                                    console.warn('Failed to parse SSE data:', e);
                                }
                            }
                        }
                    }
                } else {
                    // Regular JSON response (fallback)
                    const data = await res.json();
                    if (data.error) {
                        showError('Failed to parse log file: ' + data.error);
                        hideLoading();
                        // Show Slack button again on error
                        const slackButtonContainer = document.getElementById('slack-button-container');
                        if (slackButtonContainer) {
                            slackButtonContainer.style.display = 'block';
                        }
                    } else {
                        currentLogId = data.log_id;
                        // Add 1 second delay before reloading
                        setTimeout(() => location.reload(), 1000);
                    }
                }
            })
            .catch(error => {
                showError('Failed to parse log file: ' + error.message);
                hideLoading();
                // Show Slack button again on error
                const slackButtonContainer = document.getElementById('slack-button-container');
                if (slackButtonContainer) {
                    slackButtonContainer.style.display = 'block';
                }
            });
            
            // Reset file input
            event.target.value = '';
        }
        
        async function loadOverview() {
            currentView = 'overview';
            updateBreadcrumb();
            
            try {
                // Get log metadata to show project name
                const logsResponse = await fetch('/api/logs');
                const logs = await logsResponse.json();
                const currentLog = logs.find(log => log.id === currentLogId);
                if (currentLog) {
                    updateProjectName(currentLog.project_name);
                }
                
                const response = await fetch(`/api/log/${currentLogId}/summary`);
                const data = await response.json();
                
                hideLoading();
                
                // Show Slack copy button when log is loaded
                const slackButtonContainer = document.getElementById('slack-button-container');
                if (slackButtonContainer) {
                    slackButtonContainer.style.display = 'block';
                }
                
                displayStats(data);
                displayCharts(data);
            } catch (error) {
                hideLoading();
                showError('Failed to load summary: ' + error.message);
            }
        }
        
        function displayStats(data) {
            const statsDiv = document.getElementById('stats');
            statsDiv.style.display = 'grid';
            
            const assetImports = data.asset_imports;
            const projectLoadTime = data.project_load_time_seconds || 0;
            
            const unityVersion = data.unity_version || 'Unknown';
            
            // Update Unity version in header
            updateUnityVersion(unityVersion);
            
            // Show skeleton loaders immediately
            statsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Total Project Load Time</div>
                    <div class="stat-value">
                        ${formatTime(projectLoadTime)}
                    </div>
                </div>
                <div class="stat-card clickable" onclick="loadAllAssets()" style="cursor: pointer;" title="Click to view all assets">
                    <div class="stat-label">Total Assets</div>
                    <div class="stat-value">${assetImports.count || 0}</div>
                </div>
                <div class="stat-card" title="Note this can be longer than project load time due to parallelised import worker threads">
                    <div class="stat-label">Raw Asset Import Time</div>
                    <div class="stat-value">
                        ${formatTime((assetImports.total_time || 0) / 1000)}
                    </div>
                </div>
                <div class="stat-card clickable" id="errors-stat-card" style="cursor: pointer;" title="Click to view all errors">
                    <div class="stat-label">Total Errors</div>
                    <div class="stat-value element-spinner" style="color: #667eea;">
                        <span class="loading-spinner"></span>
                        <span>Loading...</span>
                    </div>
                </div>
                <div class="stat-card clickable" id="warnings-stat-card" style="cursor: pointer;" title="Click to view all warnings">
                    <div class="stat-label">Total Warnings</div>
                    <div class="stat-value element-spinner" style="color: #667eea;">
                        <span class="loading-spinner"></span>
                        <span>Loading...</span>
                    </div>
                </div>
            `;
            
            // Fetch error/warning counts and update
            fetch(`/api/log/${currentLogId}/error-warning-counts`)
                .then(res => res.json())
                .then(counts => {
                    const errorsCard = document.getElementById('errors-stat-card');
                    const warningsCard = document.getElementById('warnings-stat-card');
                    
                    if (errorsCard) {
                        errorsCard.innerHTML = `
                            <div class="stat-label">Total Errors</div>
                            <div class="stat-value" style="color: ${counts.errors > 0 ? '#ff4444' : '#4CAF50'};">
                                ${counts.errors || 0}
                            </div>
                        `;
                        errorsCard.onclick = () => openLogViewerWithFilter('error');
                    }
                    
                    if (warningsCard) {
                        warningsCard.innerHTML = `
                            <div class="stat-label">Total Warnings</div>
                            <div class="stat-value" style="color: ${counts.warnings > 0 ? '#ff9f40' : '#4CAF50'};">
                                ${counts.warnings || 0}
                            </div>
                        `;
                        warningsCard.onclick = () => openLogViewerWithFilter('warning');
                    }
                });
        }
        
        function displayCharts(data) {
            const chartsDiv = document.getElementById('charts');
            chartsDiv.style.display = 'grid';
            
            chartsDiv.innerHTML = `
                <div class="chart-card" style="grid-column: 1 / -1; min-height: 250px;">
                    <div id="timeline-container" style="padding: 10px 20px;">
                        <div class="element-spinner">
                            <span class="loading-spinner"></span>
                            <span>Loading timeline...</span>
                        </div>
                    </div>
                </div>
                <div class="chart-card">
                    <h2>Import Time by Category</h2>
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Total time by asset category (click for details)</p>
                    <div class="chart-container">
                        <div class="element-spinner">
                            <span class="loading-spinner"></span>
                            <span>Loading chart...</span>
                        </div>
                        <canvas id="categoryChart" style="display: none;"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <h2>Import Time by File Type</h2>
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Total time by file extension (click for details)</p>
                    <div class="chart-container">
                        <div class="element-spinner">
                            <span class="loading-spinner"></span>
                            <span>Loading chart...</span>
                        </div>
                        <canvas id="typeTimeChart" style="display: none;"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <h2>Asset Count by File Type</h2>
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Number of assets by file extension (click for details)</p>
                    <div class="chart-container">
                        <div class="element-spinner">
                            <span class="loading-spinner"></span>
                            <span>Loading chart...</span>
                        </div>
                        <canvas id="typeCountChart" style="display: none;"></canvas>
                    </div>
                </div>
                <div class="chart-card clickable" onclick="loadFolderAnalysis()" style="cursor: pointer;" title="Click to view all folders">
                    <h2>Heaviest Folders</h2>
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Top folders by total import time (click for details)</p>
                    <div class="chart-container">
                        <div class="element-spinner">
                            <span class="loading-spinner"></span>
                            <span>Loading chart...</span>
                        </div>
                        <canvas id="foldersChart" style="display: none;"></canvas>
                    </div>
                </div>
                <div class="chart-card" style="grid-column: span 2; min-height: 450px;">
                    <h2>Slowest Assets</h2>
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Top 50 slowest assets across all file types (click for details)</p>
                    <div style="max-height: 400px; overflow-y: auto;">
                        <table id="slowest-assets-table" style="width: 100%; font-size: 0.9em;">
                            <thead style="position: sticky; top: 0; background: white;">
                                <tr>
                                    <th style="text-align: left; padding: 10px; width: 35%;">Asset Name</th>
                                    <th style="text-align: left; padding: 10px; width: 8%;">File Type</th>
                                    <th style="text-align: left; padding: 10px; width: 10%;">Category</th>
                                    <th style="text-align: left; padding: 10px; width: 12%;">Importer</th>
                                    <th style="text-align: right; padding: 10px; width: 10%;">Import Time</th>
                                    <th style="text-align: left; padding: 10px;">Path</th>
                                </tr>
                            </thead>
                            <tbody id="slowest-assets-body">
                                <tr><td colspan="6" style="text-align: center; padding: 20px;">
                                    <div class="element-spinner">
                                        <span class="loading-spinner"></span>
                                        <span>Loading assets...</span>
                                    </div>
                                </td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="chart-card">
                    <h2>Script Compilation & Domain Reloads</h2>
                    <div class="chart-container">
                        <div class="element-spinner">
                            <span class="loading-spinner"></span>
                            <span>Loading chart...</span>
                        </div>
                        <canvas id="pipelineBreakdownChart" style="display: none;"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <h2>Time by Importer</h2>
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Total time by Unity importer type (click for details)</p>
                    <div class="chart-container">
                        <div class="element-spinner">
                            <span class="loading-spinner"></span>
                            <span>Loading chart...</span>
                        </div>
                        <canvas id="importerChart" style="display: none;"></canvas>
                    </div>
                </div>
                <div class="chart-card" style="min-height: 400px;">
                    <h2>Import Time Statistics by File Type</h2>
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Mean and standard deviation to identify outliers vs. consistently slow imports</p>
                    <div style="max-height: 350px; overflow-y: auto;">
                        <table id="mode-time-table" style="width: 100%; font-size: 0.9em;">
                            <thead style="position: sticky; top: 0; background: white;">
                                <tr>
                                    <th style="text-align: left; padding: 10px;">File Type</th>
                                    <th style="text-align: right; padding: 10px;">Count</th>
                                    <th style="text-align: right; padding: 10px;">Mean</th>
                                    <th style="text-align: right; padding: 10px;">Std Dev</th>
                                    <th style="text-align: left; padding: 10px;">Interpretation</th>
                                    <th style="text-align: right; padding: 10px;">Total Time</th>
                                </tr>
                            </thead>
                            <tbody id="mode-time-body">
                                <tr><td colspan="6" style="text-align: center; padding: 20px;">
                                    <div class="element-spinner">
                                        <span class="loading-spinner"></span>
                                        <span>Calculating statistics...</span>
                                    </div>
                                </td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            // Type pie chart (time) - by file extension - sorted by time
            const typeData = (data.by_type || []).slice(0, 15);  // Top 15 types by time
            const typeTimeChart = new Chart(document.getElementById('typeTimeChart'), {
                type: 'pie',
                data: {
                    labels: typeData.map(t => t.asset_type || 'Unknown'),
                    datasets: [{
                        data: typeData.map(t => (t.total_time / 1000).toFixed(2)),
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
                            '#9966FF', '#FF9F40', '#E7E9ED', '#8E5EA2',
                            '#3cba9f', '#e8c3b9', '#c45850', '#95d5b2',
                            '#ffd6a5', '#caffbf', '#fdffb6'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            position: 'right',
                            labels: {
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = parseFloat(context.parsed);
                                    const total = context.dataset.data.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return label + ': ' + formatTime(value) + ' (' + percentage + '%)';
                                }
                            }
                        },
                        datalabels: {
                            formatter: (value, ctx) => {
                                const total = ctx.dataset.data.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
                                const percentage = ((value / total) * 100);
                                if (percentage > 5) {  // Only show label if > 5%
                                    return formatTime(parseFloat(value));
                                }
                                return '';
                            },
                            color: '#333',
                            font: {
                                weight: 'bold',
                                size: 14
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const type = typeData[index].asset_type;
                            loadTypeDetail(type);
                        }
                    }
                }
            });
            showChart('typeTimeChart');
            
            // Type count chart - more reliable for worker thread imports
            const typeDataByCount = (data.by_type || []).sort((a, b) => b.count - a.count).slice(0, 15);
            const typeCountChart = new Chart(document.getElementById('typeCountChart'), {
                type: 'doughnut',
                data: {
                    labels: typeDataByCount.map(t => t.asset_type || 'Unknown'),
                    datasets: [{
                        data: typeDataByCount.map(t => t.count),
                        backgroundColor: [
                            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
                            '#9966FF', '#FF9F40', '#E7E9ED', '#8E5EA2',
                            '#3cba9f', '#e8c3b9', '#c45850', '#95d5b2',
                            '#ffd6a5', '#caffbf', '#fdffb6'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            position: 'right',
                            labels: {
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return label + ': ' + value + ' assets (' + percentage + '%)';
                                }
                            }
                        },
                        datalabels: {
                            formatter: (value, ctx) => {
                                const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = ((value / total) * 100);
                                if (percentage > 3) {  // Lower threshold for count chart
                                    return value;
                                }
                                return '';
                            },
                            color: '#333',
                            font: {
                                weight: 'bold',
                                size: 14
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const type = typeDataByCount[index].asset_type;
                            loadTypeDetail(type);
                        }
                    }
                }
            });
            showChart('typeCountChart');
            
            // Pipeline breakdown chart
            loadPipelineBreakdown();
            
            // Folders chart
            loadFoldersChart();
            
            // Importer type chart
            loadImporterChart(data.by_importer);
            
            // Mode time table
            displayModeTimeTable(data.by_type);
            
            // Slowest assets table
            loadSlowestAssets();
            
            // Category chart
            loadCategoryChart(data.by_category);
            
            // Timeline visualization
            displayTimeline(data);
        }
        
        function displayTimeline(data) {
            const container = document.getElementById('timeline-container');
            
            // Fetch timeline data
            fetch(`/api/log/${currentLogId}/timeline`)
                .then(res => res.json())
                .then(timelineData => {
                    renderTimelineVisualization(container, timelineData);
                })
                .catch(error => {
                    console.error('Failed to load timeline:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Failed to load timeline data</p>';
                });
        }
        
        function renderTimelineVisualization(container, timelineData) {
            const totalTime = timelineData.total_time_ms / 1000; // Convert to seconds
            const segments = timelineData.segments;
            const summary = timelineData.summary;
            
            // Category colors - must match the category chart
            // Colors are assigned by position in category array sorted by TOTAL TIME (same as category chart)
            const categoryChartColors = [
                '#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe',
                '#43e97b', '#fa709a', '#fee140', '#30cfd0', '#330867',
                '#a8edea', '#fed6e3', '#ffecd2', '#fcb69f', '#ff9a9e'
            ];
            
            // Calculate total time per category from segments
            const categoryTimes = {};
            segments.filter(s => s.phase === 'AssetImports' && s.category).forEach(s => {
                if (!categoryTimes[s.category]) {
                    categoryTimes[s.category] = 0;
                }
                categoryTimes[s.category] += s.duration_ms;
            });
            
            // Sort categories by total time (descending) to match category chart order
            const uniqueCategories = Object.keys(categoryTimes).sort((a, b) => {
                return categoryTimes[b] - categoryTimes[a];  // Descending order
            });
            
            // Create category -> color mapping based on time-sorted position
            const categoryColors = {};
            uniqueCategories.forEach((category, index) => {
                categoryColors[category] = categoryChartColors[index % categoryChartColors.length];
            });
            
            // Create timeline HTML
            let html = `
                <div style="margin-bottom: 10px;">
                    <h3 style="font-size: 1.8em; color: #667eea; margin-bottom: 8px;">
                        Project Load Timeline
                    </h3>
                    <p style="color: #666; font-size: 0.9em; margin-bottom: 10px;">
                        ${(() => {
                            const parts = [`Total time: ${formatTime(totalTime)}`];
                            if (summary.scan_time_ms > 0) parts.push(`Scan: ${formatTime(summary.scan_time_ms / 1000)}`);
                            if (summary.categorize_time_ms > 0) parts.push(`Categorize: ${formatTime(summary.categorize_time_ms / 1000)}`);
                            parts.push(`Asset imports: ${formatTime(summary.asset_import_time_ms / 1000)}`);
                            if (summary.operations_time_ms > 0) parts.push(`Operations: ${formatTime(summary.operations_time_ms / 1000)}`);
                            if (summary.script_compilation_time_ms > 0) parts.push(`Script compilation: ${formatTime(summary.script_compilation_time_ms / 1000)}`);
                            if (summary.post_process_time_ms > 0) parts.push(`Post-process: ${formatTime(summary.post_process_time_ms / 1000)}`);
                            if (summary.import_overhead_time_ms > 0) parts.push(`Import overhead: ${formatTime(summary.import_overhead_time_ms / 1000)}`);
                            if (summary.untracked_time_ms > 0) parts.push(`Untracked: ${formatTime(summary.untracked_time_ms / 1000)}`);
                            parts.push(`Unknown time: ${formatTime(summary.unknown_time_ms / 1000)}`);
                            return parts.join(' | ');
                        })()}
                    </p>
                </div>
                
                <div style="position: relative; width: 100%; height: 80px; background: #f5f5f5; border-radius: 8px; overflow: hidden; margin-bottom: 15px;">
            `;
            
            // Render sequential segments (non-overlapping)
            const sequentialSegments = segments.filter(s => !s.overlaps);
            const overlappingSegments = segments.filter(s => s.overlaps);
            
            sequentialSegments.forEach((segment, index) => {
                const widthPercent = (segment.duration_ms / timelineData.total_time_ms) * 100;
                const leftPercent = (segment.start_time / timelineData.total_time_ms) * 100;
                
                // Use category color for AssetImports segments
                let segmentColor = segment.color;
                if (segment.phase === 'AssetImports' && segment.category) {
                    segmentColor = categoryColors[segment.category] || segment.color;
                }
                
                const lineNumber = segment.line_number || null;
                const descriptionEscaped = (segment.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                html += `
                    <div class="timeline-segment" 
                         style="position: absolute; 
                                left: ${leftPercent}%; 
                                width: ${widthPercent}%; 
                                height: 100%; 
                                background: ${segmentColor}; 
                                cursor: pointer;
                                transition: opacity 0.2s;
                                border-right: 1px solid rgba(0,0,0,0.1);"
                         data-phase="${segment.phase}"
                         data-description="${descriptionEscaped}"
                         data-duration="${segment.duration_ms}"
                         data-line-number="${lineNumber || ''}"
                         data-category="${segment.category || ''}"
                         onmouseover="showTimelineTooltip(event, this)"
                         onmouseout="hideTimelineTooltip()"
                         onclick="navigateToLogLine(${lineNumber || 'null'})">
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // Legend - show top 5 categories only to avoid overwhelming
            html += `
                <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px; margin-top: 15px;">
            `;
            
            // Show only top 5 categories by time
            const top5Categories = uniqueCategories.slice(0, 5);
            top5Categories.forEach(category => {
                const color = categoryColors[category];
                html += `
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 20px; height: 20px; background: ${color}; border-radius: 3px;"></div>
                        <span style="font-size: 0.9em;">${category}</span>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // Tooltip container
            html += `
                <div id="timeline-tooltip" style="position: absolute; 
                                                     background: rgba(0,0,0,0.9); 
                                                     color: white; 
                                                     padding: 10px 15px; 
                                                     border-radius: 5px; 
                                                     font-size: 0.9em; 
                                                     pointer-events: none; 
                                                     z-index: 1000; 
                                                     display: none;
                                                     max-width: 300px;">
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        function showTimelineTooltip(event, element) {
            const tooltip = document.getElementById('timeline-tooltip');
            if (!tooltip) return;
            
            const description = element.getAttribute('data-description');
            const duration = parseFloat(element.getAttribute('data-duration'));
            const category = element.getAttribute('data-category');
            
            // Add category info for asset imports
            let tooltipText = description;
            if (category && category !== '') {
                tooltipText = `${description}\nCategory: ${category}`;
            }
            
            tooltip.textContent = tooltipText;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 40) + 'px';
            tooltip.style.whiteSpace = 'pre-line';  // Allow newlines in tooltip
            
            // Highlight this segment
            element.style.opacity = '0.8';
            element.style.transform = 'scaleY(1.1)';
        }
        
        function hideTimelineTooltip() {
            const tooltip = document.getElementById('timeline-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
            
            // Reset all segments
            document.querySelectorAll('.timeline-segment').forEach(seg => {
                seg.style.opacity = '1';
                seg.style.transform = 'scaleY(1)';
            });
        }
        
        function navigateToLogLine(lineNumber) {
            if (lineNumber && lineNumber > 0) {
                openLogViewer(lineNumber);
            } else {
                // Fallback if no line number available
                console.warn('No line number available for this timeline segment');
            }
        }
        
        async function displayModeTimeTable(typeData) {
            const tbody = document.getElementById('mode-time-body');
            if (!tbody) {
                console.error('Import time statistics table body not found');
                return;
            }
            
            if (!typeData || typeData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No data</td></tr>';
                return;
            }
            
            // Show loading state
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">Calculating statistics...</td></tr>';
            
            try {
                // For each type, fetch assets and calculate mean and standard deviation
                const statsPromises = typeData.map(async (type) => {
                    try {
                        const response = await fetch(`/api/log/${currentLogId}/assets/type/${encodeURIComponent(type.asset_type)}`);
                        if (!response.ok) {
                            console.error(`Failed to fetch assets for ${type.asset_type}: ${response.status}`);
                            return { ...type, mean: 0, stdDev: 0, interpretation: 'N/A' };
                        }
                        
                        const assets = await response.json();
                        
                        if (!assets || assets.length === 0) {
                            return { ...type, mean: 0, stdDev: 0, interpretation: 'No data' };
                        }
                        
                        // Convert to seconds
                        const times = assets.map(asset => asset.import_time_ms / 1000);
                        
                        // Calculate mean
                        const mean = times.reduce((sum, time) => sum + time, 0) / times.length;
                        
                        // Calculate standard deviation
                        const variance = times.reduce((sum, time) => sum + Math.pow(time - mean, 2), 0) / times.length;
                        const stdDev = Math.sqrt(variance);
                        
                        // Determine interpretation
                        // High std dev relative to mean = outliers (coefficient of variation > 1.0)
                        // Low std dev with high mean = consistently slow
                        // Low std dev with low mean = consistently fast
                        const coefficientOfVariation = mean > 0 ? stdDev / mean : 0;
                        let interpretation;
                        let interpretationColor = '#666';
                        
                        if (mean < 0.1) {
                            interpretation = 'Consistently fast';
                            interpretationColor = '#28a745';
                        } else if (coefficientOfVariation > 1.0) {
                            interpretation = 'Large Outliers';
                            interpretationColor = '#dc3545';
                        } else if (mean > 1.0) {
                            interpretation = 'Consistently slow';
                            interpretationColor = '#dc3545';
                        } else {
                            interpretation = 'Moderate variance';
                            interpretationColor = '#666';
                        }
                        
                        return { ...type, mean, stdDev, interpretation, interpretationColor };
                    } catch (error) {
                        console.error(`Failed to load assets for type ${type.asset_type}:`, error);
                        return { ...type, mean: 0, stdDev: 0, interpretation: 'Error' };
                    }
                });
                
                const typesWithStats = await Promise.all(statsPromises);
                
                // Sort by priority: Large Outliers first, then Consistently slow
                typesWithStats.sort((a, b) => {
                    if (a.interpretation === 'Large Outliers' && b.interpretation !== 'Large Outliers') return -1;
                    if (a.interpretation !== 'Large Outliers' && b.interpretation === 'Large Outliers') return 1;
                    if (a.interpretation === 'Consistently slow' && b.interpretation !== 'Consistently slow') return -1;
                    if (a.interpretation !== 'Consistently slow' && b.interpretation === 'Consistently slow') return 1;
                    return 0;
                });
                
                tbody.innerHTML = typesWithStats.map(type => {
                    // Create tooltip text based on interpretation
                    let tooltipText = '';
                    if (type.interpretation === 'Consistently fast') {
                        tooltipText = `Mean: ${formatTime(type.mean)}, Std Dev: ${formatTime(type.stdDev)}\n\nMost assets import quickly with low variance. The standard deviation is small relative to the mean, indicating consistent performance across all assets of this type.`;
                    } else if (type.interpretation === 'Large Outliers') {
                        tooltipText = `Mean: ${formatTime(type.mean)}, Std Dev: ${formatTime(type.stdDev)}\n\nHigh variance detected (std dev > mean). Most assets import quickly, but there are significant outliers that are much slower. The standard deviation being larger than the mean indicates inconsistent performance - investigate the slow outliers.`;
                    } else if (type.interpretation === 'Consistently slow') {
                        tooltipText = `Mean: ${formatTime(type.mean)}, Std Dev: ${formatTime(type.stdDev)}\n\nAll assets of this type import slowly on average. The standard deviation is relatively small compared to the mean, indicating that most assets take a similar (slow) amount of time. This suggests a systemic issue rather than outliers.`;
                    } else {
                        tooltipText = `Mean: ${formatTime(type.mean)}, Std Dev: ${formatTime(type.stdDev)}\n\nModerate variance in import times. The standard deviation is less than the mean, indicating some variation but not extreme outliers.`;
                    }
                    
                    const escapedTooltip = (tooltipText || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '<br>');
                    
                    const assetType = type.asset_type || '';
                    const escapedType = assetType.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                    
                    return `
                        <tr style="border-bottom: 1px solid #eee; cursor: pointer;" 
                            class="stats-table-row"
                            data-tooltip="${escapedTooltip}"
                            onclick="loadStdDevView('${escapedType}')">
                            <td style="padding: 10px; font-family: monospace;">${type.asset_type}</td>
                            <td style="text-align: right; padding: 10px;">${type.count}</td>
                            <td style="text-align: right; padding: 10px; font-weight: bold;">
                                ${formatTime(type.mean)}
                            </td>
                            <td style="text-align: right; padding: 10px; color: #666;">
                                ${formatTime(type.stdDev)}
                            </td>
                            <td style="padding: 10px; color: ${type.interpretationColor}; font-weight: 500; position: relative;">
                                ${type.interpretation}
                            </td>
                            <td style="text-align: right; padding: 10px; color: #666;">
                                ${formatTime(type.total_time / 1000)}
                            </td>
                        </tr>
                    `;
                }).join('');
                
                // Setup tooltips for rows
                setupStatsTableTooltips();
            } catch (error) {
                console.error('Failed to calculate import time statistics:', error);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px; color: #ff4444;">Failed to calculate import time statistics</td></tr>';
                }
            }
        }
        
        function setupStatsTableTooltips() {
            const rows = document.querySelectorAll('.stats-table-row');
            let tooltip = null;
            let hoverTimeout = null;
            
            rows.forEach(row => {
                row.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                    const tooltipText = row.getAttribute('data-tooltip');
                    if (!tooltipText) return;
                    
                    // Clear any existing timeout
                    if (hoverTimeout) {
                        clearTimeout(hoverTimeout);
                    }
                    
                    // Show tooltip after 0.5 seconds
                    hoverTimeout = setTimeout(() => {
                        // Remove existing tooltip if any
                        if (tooltip) {
                            tooltip.remove();
                        }
                        
                        // Create tooltip
                        tooltip = document.createElement('div');
                        tooltip.className = 'stats-table-tooltip';
                        tooltip.innerHTML = tooltipText;
                        tooltip.style.position = 'fixed';
                        tooltip.style.background = 'rgba(0, 0, 0, 0.9)';
                        tooltip.style.color = 'white';
                        tooltip.style.padding = '12px 16px';
                        tooltip.style.borderRadius = '6px';
                        tooltip.style.fontSize = '13px';
                        tooltip.style.lineHeight = '1.6';
                        tooltip.style.maxWidth = '350px';
                        tooltip.style.zIndex = '1000001';
                        tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                        tooltip.style.pointerEvents = 'none';
                        
                        // Position tooltip
                        const rect = row.getBoundingClientRect();
                        tooltip.style.left = (rect.right + 10) + 'px';
                        tooltip.style.top = rect.top + 'px';
                        
                        // Adjust if tooltip would go off screen
                        document.body.appendChild(tooltip);
                        const tooltipRect = tooltip.getBoundingClientRect();
                        if (tooltipRect.right > window.innerWidth) {
                            tooltip.style.left = (rect.left - tooltipRect.width - 10) + 'px';
                        }
                        if (tooltipRect.bottom > window.innerHeight) {
                            tooltip.style.top = (window.innerHeight - tooltipRect.height - 10) + 'px';
                        }
                    }, 500);
                });
                
                row.addEventListener('mouseleave', () => {
                    if (hoverTimeout) {
                        clearTimeout(hoverTimeout);
                        hoverTimeout = null;
                    }
                    if (tooltip) {
                        tooltip.remove();
                        tooltip = null;
                    }
                });
            });
        }
        
        async function loadAssetsByType(assetType) {
            try {
                const response = await fetch(`/api/log/${currentLogId}/assets/type/${encodeURIComponent(assetType)}`);
                if (!response.ok) {
                    showError('Failed to load assets: ' + response.status);
                    return;
                }
                const assets = await response.json();
                displayAssetsTable(assets, `${assetType} Assets`);
            } catch (error) {
                showError('Failed to load type detail: ' + error.message);
            }
        }
        
        async function loadStdDevView(assetType) {
            try {
                const response = await fetch(`/api/log/${currentLogId}/assets/type/${encodeURIComponent(assetType)}`);
                if (!response.ok) {
                    showError('Failed to load assets: ' + response.status);
                    return;
                }
                const assets = await response.json();
                
                if (!assets || assets.length === 0) {
                    showError('No assets found for this type');
                    return;
                }
                
                // Convert to seconds and sort by import time
                const times = assets.map(asset => asset.import_time_ms / 1000);
                const sortedAssets = assets.slice().sort((a, b) => a.import_time_ms - b.import_time_ms);
                
                // Calculate mean and standard deviation
                const mean = times.reduce((sum, time) => sum + time, 0) / times.length;
                const variance = times.reduce((sum, time) => sum + Math.pow(time - mean, 2), 0) / times.length;
                const stdDev = Math.sqrt(variance);
                
                // Calculate total time and percentage
                const totalTime = times.reduce((sum, time) => sum + time, 0);
                const summaryResponse = await fetch(`/api/log/${currentLogId}/summary`);
                const summary = await summaryResponse.json();
                const projectLoadTime = summary.project_load_time || 0;
                const percentageOfLoad = projectLoadTime > 0 
                    ? ((totalTime / projectLoadTime) * 100).toFixed(1)
                    : 'N/A';
                
                // Store the view state for back button
                stdDevViewState = {
                    assetType: assetType,
                    assets: assets,
                    mean: mean,
                    stdDev: stdDev,
                    totalTime: totalTime,
                    percentageOfLoad: percentageOfLoad
                };
                
                // Display the view
                const tablesDiv = document.getElementById('tables');
                tablesDiv.innerHTML = `
                    <div class="table-container">
                        <h2>üìä Standard Deviation Analysis: ${assetType}</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div class="stat-card" style="margin: 0;">
                                <div class="stat-label">Asset Count</div>
                                <div class="stat-value">${assets.length.toLocaleString()}</div>
                            </div>
                            <div class="stat-card" style="margin: 0;">
                                <div class="stat-label">Total Time</div>
                                <div class="stat-value">${formatTime(totalTime)}</div>
                            </div>
                            <div class="stat-card" style="margin: 0;">
                                <div class="stat-label">% of Full Load Time</div>
                                <div class="stat-value">${percentageOfLoad}${percentageOfLoad !== 'N/A' ? '%' : ''}</div>
                            </div>
                            <div class="stat-card" style="margin: 0;">
                                <div class="stat-label">Mean</div>
                                <div class="stat-value">${formatTime(mean)}</div>
                            </div>
                            <div class="stat-card" style="margin: 0;">
                                <div class="stat-label">Std Dev</div>
                                <div class="stat-value">${formatTime(stdDev)}</div>
                            </div>
                        </div>
                        <p style="margin-bottom: 15px; color: #666;">
                            üí° Distribution of import times with theoretical normal curve. <strong>Click</strong> any bar to see assets in that time range.
                        </p>
                        <div style="position: relative; height: 500px; margin-bottom: 20px;">
                            <canvas id="stdDevChart"></canvas>
                        </div>
                        <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 20px; height: 12px; background: #667eea;"></div>
                                <span style="font-size: 0.9em;">Actual Distribution (Histogram)</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 20px; height: 2px; background: #28a745;"></div>
                                <span style="font-size: 0.9em;">Theoretical Normal Curve (Mean: ${formatTime(mean)}, Std Dev: ${formatTime(stdDev)})</span>
                            </div>
                        </div>
                    </div>
                `;
                
                // Create histogram bins
                const minTime = Math.min(...times);
                const maxTime = Math.max(...times);
                const binCount = Math.min(30, Math.max(10, Math.floor(Math.sqrt(assets.length)))); // Adaptive bin count
                const binWidth = (maxTime - minTime) / binCount || 0.001; // Avoid division by zero
                
                // Create bins and count assets in each
                const bins = Array(binCount).fill(0).map((_, i) => {
                    const binStart = minTime + (i * binWidth);
                    const binEnd = i === binCount - 1 ? maxTime + 0.001 : minTime + ((i + 1) * binWidth);
                    return {
                        start: binStart,
                        end: binEnd,
                        center: (binStart + binEnd) / 2,
                        count: 0,
                        assets: []
                    };
                });
                
                // Assign assets to bins
                assets.forEach(asset => {
                    const timeSeconds = asset.import_time_ms / 1000;
                    const binIndex = Math.min(
                        Math.floor((timeSeconds - minTime) / binWidth),
                        binCount - 1
                    );
                    bins[binIndex].count++;
                    bins[binIndex].assets.push(asset);
                });
                
                // Calculate theoretical normal distribution curve at bin centers
                // Normal distribution PDF: f(x) = (1 / (œÉ * ‚àö(2œÄ))) * e^(-0.5 * ((x - Œº) / œÉ)¬≤)
                const maxCount = Math.max(...bins.map(b => b.count), 1); // Avoid division by zero
                
                // Create invisible full-height bars for better click/hover interaction
                // These will be positioned behind the visible bars
                const interactionHeight = maxCount * 1.2; // Extend slightly above max for full coverage
                
                // Calculate normal distribution values at each bin center
                // Scale to match the histogram height
                const normalCurveValues = bins.map(bin => {
                    const x = bin.center;
                    const z = (x - mean) / stdDev;
                    const pdf = (1 / (stdDev * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * z * z);
                    
                    // Scale to match histogram: multiply by total number of assets and bin width
                    // This gives the expected count in each bin for a normal distribution
                    const expectedCount = pdf * assets.length * binWidth;
                    return expectedCount;
                });
                
                // Create chart
                const ctx = document.getElementById('stdDevChart').getContext('2d');
                
                // Destroy existing chart if it exists
                if (window.stdDevChartInstance) {
                    window.stdDevChartInstance.destroy();
                }
                
                // Store bin data for click handling
                window.stdDevBins = bins;
                
                window.stdDevChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => formatTime(b.center)),
                        datasets: [
                            {
                                // Invisible interaction layer - full height bars for easier clicking
                                // Using very low opacity instead of transparent to ensure clicks register
                                label: '',
                                data: bins.map(() => interactionHeight),
                                backgroundColor: 'rgba(0, 0, 0, 0.01)', // Nearly transparent but clickable
                                borderColor: 'rgba(0, 0, 0, 0.01)',
                                borderWidth: 0,
                                order: 3, // Behind other datasets
                                datalabels: {
                                    display: false
                                }
                            },
                            {
                                label: 'Asset Count',
                                data: bins.map(b => b.count),
                                backgroundColor: 'rgba(102, 126, 234, 0.7)',
                                borderColor: 'rgba(102, 126, 234, 1)',
                                borderWidth: 1,
                                order: 2 // In front of interaction layer
                            },
                            {
                                label: 'Normal Distribution',
                                data: normalCurveValues,
                                type: 'line',
                                borderColor: '#28a745',
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHitRadius: 0, // Don't intercept clicks
                                fill: false,
                                tension: 0.4,
                                order: 1, // In front of bars
                                datalabels: {
                                    display: false  // Hide labels on the normal distribution curve
                                }
                            },
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Import Time (seconds)'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45,
                                    callback: function(value, index) {
                                        // Show every nth label to avoid crowding
                                        const step = Math.max(1, Math.floor(bins.length / 10));
                                        return index % step === 0 ? formatTime(bins[index].center) : '';
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Number of Assets'
                                },
                                beginAtZero: true
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    filter: function(item, chart) {
                                        // Only show the visible histogram bars in legend (dataset index 1)
                                        return item.datasetIndex === 1;
                                    }
                                }
                            },
                            datalabels: {
                                display: function(context) {
                                    // Only show labels on the visible histogram bars (dataset index 1), not interaction layer or curve
                                    return context.datasetIndex === 1;
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        // Show tooltip for interaction layer (0) or visible bars (1)
                                        if (context[0].datasetIndex === 0 || context[0].datasetIndex === 1) {
                                            const binIndex = context[0].dataIndex;
                                            const bin = bins[binIndex];
                                            return `${formatTime(bin.start)} - ${formatTime(bin.end)}`;
                                        }
                                        return '';
                                    },
                                    label: function(context) {
                                        // Show tooltip for interaction layer (0) or visible bars (1)
                                        if (context.datasetIndex === 0 || context.datasetIndex === 1) {
                                            const binIndex = context.dataIndex;
                                            const bin = bins[binIndex];
                                            return `${bin.count} assets in this range`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            console.log('Chart clicked', elements);
                            const chart = window.stdDevChartInstance;
                            
                            // Get the x position of the click
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                            const xValue = chart.scales.x.getValueForPixel(canvasPosition.x);
                            
                            console.log('Click x position (time value):', xValue);
                            
                            // Find the bin that contains this x value (time value)
                            // The x-axis shows time values, so we need to match the clicked time to a bin
                            let binIndex = -1;
                            
                            // Try to get binIndex from element if available
                            if (elements && elements.length > 0) {
                                const barElement = elements.find(el => (el.datasetIndex === 0 || el.datasetIndex === 1) && el.index !== undefined);
                                if (barElement && barElement.index !== undefined) {
                                    binIndex = barElement.index;
                                    console.log('Found bin index from element:', binIndex);
                                }
                            }
                            
                            // If we couldn't get it from element, find by time value
                            if (binIndex < 0) {
                                binIndex = bins.findIndex(bin => {
                                    return xValue >= bin.start && xValue <= bin.end;
                                });
                                console.log('Found bin index from time value:', binIndex, 'for time:', xValue);
                            }
                            
                            if (binIndex >= 0 && binIndex < bins.length) {
                                const bin = bins[binIndex];
                                console.log('Bin found:', binIndex, 'with', bin.assets ? bin.assets.length : 0, 'assets');
                                
                                if (bin && bin.assets && bin.assets.length > 0) {
                                    console.log('Displaying assets table for bin:', binIndex);
                                    displayAssetsTable(bin.assets, `${assetType} Assets (${formatTime(bin.start)} - ${formatTime(bin.end)})`);
                                } else {
                                    console.log('No assets in bin');
                                }
                            } else {
                                console.log('Could not determine bin index');
                            }
                        },
                        onHover: (event, elements) => {
                            // Show pointer cursor for interaction layer or visible bars
                            const isClickable = elements.length > 0 && (elements[0].datasetIndex === 0 || elements[0].datasetIndex === 1);
                            event.native.target.style.cursor = isClickable ? 'pointer' : 'default';
                        }
                    }
                });
                
                // Auto-scroll to view
                setTimeout(() => {
                    tablesDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
                
            } catch (error) {
                showError('Failed to load standard deviation view: ' + error.message);
                console.error('Error loading std dev view:', error);
            }
        }
        
        function restoreStdDevView() {
            if (stdDevViewState) {
                // Restore the histogram view
                loadStdDevView(stdDevViewState.assetType);
            }
        }
        
        async function loadSlowestAssets() {
            const tbody = document.getElementById('slowest-assets-body');
            if (!tbody) return;
            
            try {
                const response = await fetch(`/api/log/${currentLogId}/assets`);
                const assets = await response.json();
                
                if (!assets || assets.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No assets found</td></tr>';
                    return;
                }
                
                // Sort by import time (descending) and take top 50
                const slowest = assets
                    .sort((a, b) => b.import_time_ms - a.import_time_ms)
                    .slice(0, 50);
                
                tbody.innerHTML = slowest.map((asset, index) => {
                    const timeSeconds = asset.import_time_ms / 1000;
                    const timeFormatted = formatTime(timeSeconds);
                    const category = asset.asset_category || 'Unknown';
                    const importer = asset.importer_type || 'Unknown';
                    const assetPath = asset.asset_path || '';
                    const path = assetPath.length > 60
                        ? assetPath.substring(0, 57) + '...'
                        : assetPath;
                    const escapedPath = assetPath.replace(/"/g, '&quot;');
                
                return `
                        <tr data-line="${asset.line_number}" 
                            data-path="${escapedPath}"
                            style="cursor: pointer; border-bottom: 1px solid #eee;">
                            <td style="padding: 10px; width: 35%;">
                                <strong style="color: #1a1a1a; font-size: 0.9em; word-break: break-word;">${asset.asset_name}</strong>
                            </td>
                            <td style="padding: 10px; font-family: monospace; font-size: 0.85em; width: 8%;">${asset.asset_type || 'N/A'}</td>
                            <td style="padding: 10px; font-size: 0.85em; width: 10%;">
                                <span style="display: inline-block; padding: 2px 8px; background: #e3f2fd; color: #1976d2; border-radius: 3px; font-size: 0.8em;">${category}</span>
                            </td>
                            <td style="padding: 10px; font-family: monospace; font-size: 0.95em; color: #666; width: 12%;">${importer}</td>
                            <td style="text-align: right; padding: 10px; font-weight: bold; color: #f57c00; width: 10%;">
                                ${timeFormatted}
                            </td>
                            <td style="padding: 10px; font-size: 0.85em; color: #666;">
                                ${path}
                            </td>
                        </tr>
                    `;
                }).join('');
                
                // Add event listeners for click and context menu
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    const lineNumber = row.getAttribute('data-line');
                    const path = row.getAttribute('data-path');
                    
                    // Left click to navigate
                    row.addEventListener('click', () => {
                        openLogViewer(lineNumber);
                    });
                    
                    // Right click for context menu
                    row.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // Decode the path from HTML entity
                        const decodedPath = path.replace(/&quot;/g, '"');
                        showContextMenu(e, decodedPath);
                    });
                });
            } catch (error) {
                console.error('Failed to load slowest assets:', error);
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px; color: #ff4444;">Failed to load assets</td></tr>';
                }
            }
        }
        
        async function loadCategoryDetail(category) {
            currentView = 'category';
            currentFilter = category;
            updateBreadcrumb();
            
            showLoading();
            
            try {
                const response = await fetch(`/api/log/${currentLogId}/assets/category/${encodeURIComponent(category)}`);
                const assets = await response.json();
                
                hideLoading();
                
                displayAssetsTable(assets, `${category} Assets`);
            } catch (error) {
                showError('Failed to load category detail: ' + error.message);
            }
        }
        
        async function loadTypeDetail(type) {
            currentView = 'type';
            currentFilter = type;
            updateBreadcrumb();
            
            showLoading();
            
            try {
                const response = await fetch(`/api/log/${currentLogId}/assets/type/${encodeURIComponent(type)}`);
                const assets = await response.json();
                
                hideLoading();
                
                displayAssetsTable(assets, `${type} Assets`);
            } catch (error) {
                showError('Failed to load type detail: ' + error.message);
            }
        }
        
        async function loadAllAssets() {
            currentView = 'all_assets';
            currentFilter = 'All Assets';
            updateBreadcrumb();
            
            showLoading();
            
            try {
                const response = await fetch(`/api/log/${currentLogId}/assets`);
                const assets = await response.json();
                
                hideLoading();
                
                displayAssetsTable(assets, 'All Assets');
            } catch (error) {
                showError('Failed to load all assets: ' + error.message);
            }
        }
        
        async function loadFolderAnalysis() {
            currentView = 'folder_analysis';
            currentFilter = 'Folder Analysis';
            updateBreadcrumb();
            
            showLoading();
            
            try {
                const response = await fetch(`/api/log/${currentLogId}/folder-analysis`);
                const folders = await response.json();
                
                hideLoading();
                
                displayFolderAnalysisTable(folders);
                
                // Auto-scroll to tables
                setTimeout(() => {
                    document.getElementById('tables').scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            } catch (error) {
                showError('Failed to load folder analysis: ' + error.message);
            }
        }
        
        async function loadFolderAssets(folderPath) {
            currentView = 'folder_assets';
            currentFilter = `Assets in ${folderPath}`;
            updateBreadcrumb();
            
            showLoading();
            
            try {
                // Get all assets and filter by folder path
                const response = await fetch(`/api/log/${currentLogId}/assets`);
                const allAssets = await response.json();
                
                // Filter assets that start with this folder path
                const folderAssets = allAssets.filter(asset => 
                    asset.asset_path.startsWith(folderPath + '/')
                ).sort((a, b) => b.import_time_ms - a.import_time_ms);
                
                hideLoading();
                
                displayAssetsTable(folderAssets, `Assets in ${folderPath}`, `Showing ${folderAssets.length} assets in folder`);
            } catch (error) {
                showError('Failed to load folder assets: ' + error.message);
            }
        }
        
        function displayFolderAnalysisTable(folders) {
            const tablesDiv = document.getElementById('tables');
            
            // Calculate summary stats
            const totalAssets = folders.reduce((sum, f) => sum + (f.asset_count || 0), 0);
            const totalTime = folders.reduce((sum, f) => sum + (f.total_time_ms || 0), 0);
            
            // Get project load time for percentage
            let projectLoadTimeSeconds = 0;
            fetch(`/api/log/${currentLogId}/summary`)
                .then(res => res.json())
                .then(summary => {
                    projectLoadTimeSeconds = summary.project_load_time_seconds || 0;
                    const percentageOfLoad = projectLoadTimeSeconds > 0 
                        ? ((totalTime / 1000 / projectLoadTimeSeconds) * 100).toFixed(1)
                        : 'N/A';
                    
                    tablesDiv.innerHTML = `
                        <div class="table-container">
                            <h2>üìÅ Folder Analysis - Heaviest Folders by Import Time</h2>
                            <p style="margin-bottom: 15px; color: #666;">
                                üí° Shows folders 3-4 levels deep, sorted by total import time. <strong>Click</strong> a folder to see all assets in that folder. <strong>Right-click</strong> to copy folder path.
                            </p>
                            <div style="max-height: 600px; overflow-y: auto; overflow-x: hidden;" id="folder-table-scroll">
                                <table>
                                    <thead style="position: sticky; top: 0; background: white; z-index: 10;">
                                        <tr>
                                            <th style="width: 40%;">Folder</th>
                                            <th style="width: 70px; text-align: center;">Count</th>
                                            <th style="width: 90px; text-align: right;">Total Time</th>
                                            <th style="width: 80px; text-align: right;">Avg Time</th>
                                            <th>Top Assets</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                ${folders.map((folder, idx) => {
                                    // Handle null folder path
                                    const folderPath = folder.folder || '';
                                    
                                    // Truncate folder path intelligently - show more parts with 300px width
                                    let folderDisplay = folderPath;
                                    const parts = folderDisplay.split('/');
                                    if (parts.length > 4) {
                                        folderDisplay = '.../' + parts.slice(-4).join('/');
                                    } else if (folderDisplay.length > 50) {
                                        folderDisplay = folderDisplay.substring(0, 47) + '...';
                                    }
                                    
                                    const escapedFolderPath = folderPath.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                                    
                                    // Truncate asset names - allow more space now
                                    const truncateAssetName = (name, maxLength = 50) => {
                                        if (name.length <= maxLength) return name;
                                        return name.substring(0, maxLength - 3) + '...';
                                    };
                                    
                                    return `
                                    <tr onclick="loadFolderAssets('${escapedFolderPath}')" 
                                        title="${folderPath} - Click to view all assets"
                                        data-folder-path="${escapedFolderPath}">
                                        <td style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                            <span class="mono" style="font-size: 0.9em;">${folderDisplay}</span>
                                        </td>
                                        <td style="text-align: center;">
                                            <span class="badge">${folder.asset_count.toLocaleString()}</span>
                                        </td>
                                        <td style="text-align: right;">
                                            <strong>${formatTime(folder.total_time_ms / 1000)}</strong>
                                        </td>
                                        <td style="text-align: right; color: #666;">${formatTime(folder.avg_time_ms / 1000)}</td>
                                        <td style="font-size: 0.85em;">
                                            ${folder.assets.slice(0, 5).map(asset => {
                                                const assetName = asset.path.split('/').pop();
                                                const truncatedName = truncateAssetName(assetName, 50);
                                                return `
                                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 2px 0;">
                                                    <span style="color: #555; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; margin-right: 8px;" title="${assetName}">${truncatedName}</span>
                                                    <span style="color: #667eea; font-weight: 500; flex-shrink: 0;">${formatTime(asset.time_ms / 1000)}</span>
                                                </div>
                                            `;
                                            }).join('')}
                                            ${folder.assets.length > 5 ? `<div style="color: #999; font-size: 0.8em; padding-top: 4px; font-style: italic;">+${folder.assets.length - 5} more</div>` : ''}
                                        </td>
                                    </tr>
                                `;
                                }).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                    
                    // Setup context menu for folder paths
                    setupFolderTableContextMenus();
                })
                .catch(err => {
                    console.error('Failed to get project load time:', err);
                    // Fallback without percentage
                    tablesDiv.innerHTML = `
                        <div class="table-container">
                            <h2>üìÅ Folder Analysis - Heaviest Folders by Import Time</h2>
                            <p style="margin-bottom: 15px; color: #666;">
                                üí° Shows folders 3-4 levels deep, sorted by total import time. <strong>Click</strong> a folder to see all assets in that folder. <strong>Right-click</strong> to copy folder path.
                            </p>
                            <div style="max-height: 600px; overflow-y: auto; overflow-x: hidden;" id="folder-table-scroll">
                                <table>
                                    <thead style="position: sticky; top: 0; background: white; z-index: 10;">
                                        <tr>
                                            <th style="width: 40%;">Folder</th>
                                            <th style="width: 70px; text-align: center;">Count</th>
                                            <th style="width: 90px; text-align: right;">Total Time</th>
                                            <th style="width: 80px; text-align: right;">Avg Time</th>
                                            <th>Top Assets</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${folders.map((folder, idx) => {
                                            const folderPath = folder.folder || '';
                                            const parts = folderPath.split('/');
                                            let folderDisplay = parts.length > 3 
                                                ? '.../' + parts.slice(-3).join('/')
                                                : folderPath.length > 30 
                                                    ? folderPath.substring(0, 27) + '...'
                                                    : folderPath;
                                            const escapedFolderPath = folderPath.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                                            const truncateAssetName = (name, maxLength = 22) => {
                                                if (name.length <= maxLength) return name;
                                                return name.substring(0, maxLength - 3) + '...';
                                            };
                                            return `
                                            <tr onclick="loadFolderAssets('${escapedFolderPath}')" 
                                                title="${folderPath} - Click to view all assets"
                                                data-folder-path="${escapedFolderPath}">
                                                <td style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                                    <span class="mono" style="font-size: 0.9em;">${folderDisplay}</span>
                                                </td>
                                                <td style="text-align: center;">
                                                    <span class="badge">${folder.asset_count.toLocaleString()}</span>
                                                </td>
                                                <td style="text-align: right;">
                                                    <strong>${formatTime(folder.total_time_ms / 1000)}</strong>
                                                </td>
                                                <td style="text-align: right; color: #666;">${formatTime(folder.avg_time_ms / 1000)}</td>
                                                <td style="font-size: 0.85em;">
                                                    ${folder.assets.slice(0, 5).map(asset => {
                                                        const assetName = asset.path.split('/').pop();
                                                        const truncatedName = truncateAssetName(assetName, 22);
                                                        return `
                                                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 2px 0;">
                                                            <span style="color: #555; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; margin-right: 8px;" title="${assetName}">${truncatedName}</span>
                                                            <span style="color: #667eea; font-weight: 500; flex-shrink: 0;">${formatTime(asset.time_ms / 1000)}</span>
                                                        </div>
                                                    `;
                                                    }).join('')}
                                                    ${folder.assets.length > 5 ? `<div style="color: #999; font-size: 0.8em; padding-top: 4px; font-style: italic;">+${folder.assets.length - 5} more</div>` : ''}
                                                </td>
                                            </tr>
                                        `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    `;
                    
                    // Setup context menu for folder paths
                    setupFolderTableContextMenus();
                });
        }
        
        function setupFolderTableContextMenus() {
            const tbody = document.querySelector('#folder-table-scroll tbody');
            if (!tbody) {
                console.log('Folder table tbody not found');
                return;
            }
            
            const rows = tbody.querySelectorAll('tr');
            console.log('Found', rows.length, 'rows in folder table');
            
            rows.forEach((row, index) => {
                const path = row.getAttribute('data-folder-path');
                if (!path) {
                    console.log('Row', index, 'has no data-folder-path attribute');
                    return;
                }
                
                // Decode the path from HTML entity
                const decodedPath = path.replace(/&quot;/g, '"');
                
                row.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Right-click on folder row, path:', decodedPath);
                    showContextMenu(e, decodedPath);
                });
            });
        }
        
        async function loadFoldersChart() {
            try {
                const response = await fetch(`/api/log/${currentLogId}/folder-analysis`);
                const folders = await response.json();
                
                // Top 6 folders
                const topFolders = folders.slice(0, 6);
                
                const foldersChart = new Chart(document.getElementById('foldersChart'), {
                    type: 'doughnut',
                    data: {
                        labels: topFolders.map(f => f.folder.split('/').slice(-2).join('/')),  // Show last 2 parts
                        datasets: [{
                            data: topFolders.map(f => (f.total_time_ms / 1000).toFixed(2)),
                            backgroundColor: [
                                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'
                            ],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    font: { size: 10 }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const folder = topFolders[context.dataIndex];
                                        return [
                                            `Path: ${folder.folder}`,
                                            `Time: ${formatTime(folder.total_time_ms / 1000)}`,
                                            `Assets: ${folder.asset_count}`
                                        ];
                                    }
                                }
                            },
                            datalabels: {
                                formatter: (value, ctx) => {
                                    return formatTime(parseFloat(value));
                                },
                                color: '#333',
                                font: {
                                    weight: 'bold',
                                    size: 13
                                }
                            }
                        }
                    }
                });
                showChart('foldersChart');
            } catch (error) {
                console.error('Failed to load folders chart:', error);
                const container = document.getElementById('foldersChart').parentElement;
                const spinner = container.querySelector('.element-spinner');
                if (spinner) spinner.innerHTML = '<span style="color: #ff4444;">Failed to load chart</span>';
            }
        }
        
        function loadImporterChart(importerData) {
            if (!importerData || importerData.length === 0) {
                const container = document.getElementById('importerChart').parentElement;
                const spinner = container.querySelector('.element-spinner');
                if (spinner) spinner.innerHTML = '<span>No importer data available</span>';
                return;
            }
            
            // Top 10 importers by time
            const topImporters = importerData.slice(0, 10);
            
            const ctx = document.getElementById('importerChart');
            const importerChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: topImporters.map(i => (i.importer_type || 'Unknown').replace('Importer', '')),
                    datasets: [{
                        label: 'Total Time',
                        data: topImporters.map(i => (i.total_time / 1000).toFixed(2)),
                        backgroundColor: '#667eea'
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const importer = topImporters[context.dataIndex];
                                    return [
                                        `Total: ${formatTime(importer.total_time / 1000)}`,
                                        `Count: ${importer.count} assets`,
                                        `Avg: ${formatTime(importer.avg_time / 1000)}`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            anchor: 'end',
                            align: 'end',
                            formatter: (value) => formatTime(parseFloat(value)),
                            color: '#333',
                            font: {
                                weight: 'bold',
                                size: 10
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Total Import Time'
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const importer = topImporters[index];
                            loadImporterDetail(importer.importer_type);
                        }
                    }
                }
            });
            showChart('importerChart');
        }
        
        function loadCategoryChart(categoryData) {
            console.log('loadCategoryChart called with:', categoryData);
            
            if (!categoryData || categoryData.length === 0) {
                console.warn('No category data available');
                const ctx = document.getElementById('categoryChart');
                if (ctx && ctx.parentElement) {
                    ctx.parentElement.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">No category data available</p>';
                }
                return;
            }
            
            // Top 15 categories by time
            const topCategories = categoryData.slice(0, 15);
            console.log('Top categories:', topCategories);
            
            const ctx = document.getElementById('categoryChart');
            if (!ctx) {
                console.error('Category chart canvas not found');
                return;
            }
            
            // Destroy existing chart if it exists
            if (ctx.chart) {
                ctx.chart.destroy();
            }
            
            // Convert total_time (in ms) to seconds for chart
            const chartData = topCategories.map(c => {
                const timeMs = c.total_time || 0;
                return parseFloat((timeMs / 1000).toFixed(2));
            });
            
            console.log('Chart data:', chartData);
            console.log('Labels:', topCategories.map(c => c.asset_category || 'Unknown'));
            
            ctx.chart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: topCategories.map(c => c.asset_category || 'Unknown'),
                    datasets: [{
                        data: chartData,
                        backgroundColor: [
                            '#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe',
                            '#43e97b', '#fa709a', '#fee140', '#30cfd0', '#330867',
                            '#a8edea', '#fed6e3', '#ffecd2', '#fcb69f', '#ff9a9e'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                padding: 15,
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const category = topCategories[context.dataIndex];
                                    const total = chartData.reduce((sum, val) => sum + parseFloat(val), 0);
                                    const percentage = total > 0 ? ((parseFloat(context.parsed) / total) * 100).toFixed(1) : '0.0';
                                    return [
                                        `${context.label}: ${formatTime(parseFloat(context.parsed))}`,
                                        `Count: ${category.count || 0} assets`,
                                        `Avg: ${formatTime((category.avg_time || 0) / 1000)}`,
                                        `${percentage}% of total`
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            formatter: (value, ctx) => {
                                const total = ctx.dataset.data.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
                                if (total === 0 || !value || value === 0) return '';
                                const percentage = ((parseFloat(value) / total) * 100);
                                if (percentage > 5) {
                                    return formatTime(parseFloat(value));
                                }
                                return '';
                            },
                            color: '#333',
                            font: {
                                weight: 'bold',
                                size: 14
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const category = topCategories[index];
                            loadCategoryDetail(category.asset_category);
                        }
                    }
                }
            });
            showChart('categoryChart');
        }
        
        async function loadCategoryDetail(category) {
            currentView = 'category_assets';
            currentFilter = `${category} Assets`;
            updateBreadcrumb();
            
            showLoading();
            
            try {
                const response = await fetch(`/api/log/${currentLogId}/assets/category/${encodeURIComponent(category)}`);
                const assets = await response.json();
                
                hideLoading();
                
                displayAssetsTable(assets, `${category} Assets`);
            } catch (error) {
                showError('Failed to load category assets: ' + error.message);
            }
        }
        
        // Context menu for right-click copy
        let contextMenu = null;
        
        function showContextMenu(event, path) {
            event.preventDefault();
            event.stopPropagation();
            
            console.log('showContextMenu called with path:', path);
            
            // Remove existing menu
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
            
            // Create menu
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            
            // Set position and visibility explicitly
            // Use clientX/clientY instead of pageX/pageY to account for scroll
            const x = event.clientX;
            const y = event.clientY;
            
            contextMenu.style.position = 'fixed';
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.style.display = 'block';
            contextMenu.style.visibility = 'visible';
            contextMenu.style.opacity = '1';
            contextMenu.style.zIndex = '1000000';
            contextMenu.style.backgroundColor = 'white';
            contextMenu.style.border = '1px solid #ddd';
            contextMenu.style.borderRadius = '4px';
            contextMenu.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
            contextMenu.style.padding = '4px 0';
            contextMenu.style.minWidth = '150px';
            contextMenu.style.pointerEvents = 'auto';
            contextMenu.style.margin = '0';
            contextMenu.style.transform = 'none';
            
            // Create menu item with event listener instead of inline onclick
            const menuItem = document.createElement('div');
            menuItem.className = 'context-menu-item';
            menuItem.textContent = 'Copy Path';
            menuItem.style.padding = '8px 16px';
            menuItem.style.cursor = 'pointer';
            menuItem.style.fontSize = '13px';
            menuItem.style.color = '#333';
            menuItem.addEventListener('click', (e) => {
                e.stopPropagation();
                copyToClipboard(path);
                hideContextMenu();
            });
            menuItem.addEventListener('mouseenter', () => {
                menuItem.style.backgroundColor = '#f0f0f0';
            });
            menuItem.addEventListener('mouseleave', () => {
                menuItem.style.backgroundColor = 'transparent';
            });
            
            contextMenu.appendChild(menuItem);
            
            // Append to body, ensuring it's not clipped by any container
            document.body.appendChild(contextMenu);
            
            // Force a reflow to ensure styles are applied
            contextMenu.offsetHeight;
            
            // Use requestAnimationFrame to ensure DOM is ready
            requestAnimationFrame(() => {
                if (!contextMenu || !contextMenu.parentNode) {
                    console.error('Context menu was removed before it could be displayed!');
                    return;
                }
                
                // Force visibility - use !important via setProperty
                contextMenu.style.setProperty('display', 'block', 'important');
                contextMenu.style.setProperty('visibility', 'visible', 'important');
                contextMenu.style.setProperty('opacity', '1', 'important');
                contextMenu.style.setProperty('z-index', '1000000', 'important');
                
                const rect = contextMenu.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(contextMenu);
                console.log('Menu rect after append:', rect);
                console.log('Menu computed display:', computedStyle.display);
                console.log('Menu computed visibility:', computedStyle.visibility);
                console.log('Menu computed opacity:', computedStyle.opacity);
                console.log('Menu computed z-index:', computedStyle.zIndex);
                console.log('Menu parent:', contextMenu.parentNode);
                
                // If menu is outside viewport, adjust position
                if (rect.right > window.innerWidth) {
                    contextMenu.style.left = (window.innerWidth - rect.width - 10) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    contextMenu.style.top = (event.clientY - rect.height - 10) + 'px';
                }
                if (rect.left < 0) {
                    contextMenu.style.left = '10px';
                }
                if (rect.top < 0) {
                    contextMenu.style.top = '10px';
                }
                
                // Ensure menu is visible in viewport
                const viewportTop = window.scrollY;
                const viewportBottom = window.scrollY + window.innerHeight;
                if (rect.top < viewportTop || rect.bottom > viewportBottom) {
                    // Position relative to click point, but ensure it's visible
                    const newTop = Math.min(event.clientY, window.innerHeight - rect.height - 10);
                    contextMenu.style.top = Math.max(10, newTop) + 'px';
                }
                
                // Final check - is it actually visible?
                const finalRect = contextMenu.getBoundingClientRect();
                if (finalRect.width === 0 || finalRect.height === 0) {
                    console.error('Menu has zero dimensions!', finalRect);
                }
            });
            
            // Close on click outside - but wait a bit to ensure menu is visible
            setTimeout(() => {
                const clickHandler = (e) => {
                    // Only hide if click is outside the menu
                    if (contextMenu && !contextMenu.contains(e.target)) {
                        hideContextMenu();
                        document.removeEventListener('click', clickHandler);
                    }
                };
                document.addEventListener('click', clickHandler);
            }, 200);
        }
        
        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Show feedback
                const feedback = document.createElement('div');
                feedback.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 10px 20px; border-radius: 5px; z-index: 10001;';
                feedback.textContent = '‚úì Path copied to clipboard';
                document.body.appendChild(feedback);
                setTimeout(() => feedback.remove(), 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
        
        async function loadImporterDetail(importerType) {
            try {
                const response = await fetch(`/api/log/${currentLogId}/assets-by-importer/${encodeURIComponent(importerType)}`);
                const assets = await response.json();
                
                updateBreadcrumb([
                    { label: 'Dashboard', action: 'loadSummary()' },
                    { label: `Importer: ${importerType}`, action: null }
                ]);
                
                currentView = 'importer';
                currentFilter = importerType;
                
                displayAssetsTable(assets, `Assets using ${importerType}`);
            } catch (error) {
                showError('Failed to load importer details: ' + error.message);
            }
        }
        
        async function loadPipelineBreakdown() {
            try {
                const response = await fetch(`/api/log/${currentLogId}/pipeline-breakdown`);
                const breakdown = await response.json();
                
                const labels = [];
                const values = [];
                
                // Only show Script Compilation and Domain Reloads
                if (breakdown.total_compile) {
                    labels.push('Script Compilation');
                    values.push((breakdown.total_compile / 1000).toFixed(2));
                }
                if (breakdown.total_domain_reload) {
                    labels.push('Domain Reloads');
                    values.push((breakdown.total_domain_reload / 1000).toFixed(2));
                }
                
                const pipelineChart = new Chart(document.getElementById('pipelineBreakdownChart'), {
                    type: 'pie',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: values,
                            backgroundColor: [
                                '#9966FF', '#FF9F40'
                            ],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'right' },
                            tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = parseFloat(context.parsed);
                                    const total = context.dataset.data.reduce((a, b) => parseFloat(a) + parseFloat(b), 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return label + ': ' + formatTime(value) + ' (' + percentage + '%)';
                                }
                            }
                        },
                        datalabels: {
                            formatter: (value, ctx) => {
                                return formatTime(parseFloat(value));
                            },
                            color: '#333',
                            font: {
                                weight: 'bold',
                                size: 14
                            }
                        }
                    },
                    onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const label = labels[index];
                                loadPipelineDetails(label);
                            }
                        }
                    }
                });
                showChart('pipelineBreakdownChart');
            } catch (error) {
                console.error('Failed to load pipeline breakdown:', error);
                const container = document.getElementById('pipelineBreakdownChart').parentElement;
                const spinner = container.querySelector('.element-spinner');
                if (spinner) spinner.innerHTML = '<span style="color: #ff4444;">Failed to load chart</span>';
            }
        }
        
        async function loadPipelineDetails(category) {
            currentView = 'pipeline';
            currentFilter = category;
            updateBreadcrumb();
            
            showLoading();
            
            try {
                const response = await fetch(`/api/log/${currentLogId}/pipeline-refreshes`);
                const refreshes = await response.json();
                
                hideLoading();
                
                displayPipelineTable(refreshes, category);
                
                // Auto-scroll to tables
                setTimeout(() => {
                    document.getElementById('tables').scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            } catch (error) {
                showError('Failed to load pipeline details: ' + error.message);
            }
        }
        
        function displayPipelineTable(refreshes, category) {
            const tablesDiv = document.getElementById('tables');
            
            // Map category to field name
            const categoryFieldMap = {
                'Asset DB Processing': 'asset_db_process_time_ms',
                'Asset DB Callbacks': 'asset_db_callback_time_ms',
                'Domain Reloads': 'domain_reload_time_ms',
                'Script Compilation': 'compile_time_ms',
                'Other Scripting': 'scripting_other_ms'
            };
            
            const fieldName = categoryFieldMap[category];
            
            tablesDiv.innerHTML = `
                <div class="table-container">
                    <h2>Pipeline Refresh: ${category}</h2>
                    <p style="margin-bottom: 20px; color: #666;">
                        üí° <strong>Hover</strong> over rows for details ‚Ä¢ <strong>Click</strong> any row or line number to jump to that location in the log
                    </p>
                    <div style="max-height: 600px; overflow-y: auto; overflow-x: hidden;">
                        <table>
                            <thead style="position: sticky; top: 0; background: white; z-index: 10;">
                                <tr>
                                    <th style="width: 80px;">Line #</th>
                                    <th style="width: 120px;">Refresh ID</th>
                                    <th style="width: 130px;">${category} Time</th>
                                    <th style="width: 110px;">% of Total</th>
                                    <th style="width: 110px;">Total Time</th>
                                    <th style="min-width: 150px;">Initiated By</th>
                                    <th style="width: 100px;">Imports</th>
                                    <th style="min-width: 200px;">Details</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${refreshes.map(refresh => {
                                    const timeValue = refresh[fieldName];
                                    const timeFormatted = timeValue ? formatTime(timeValue / 1000) : 'N/A';
                                    const totalTime = formatTime(refresh.total_time_seconds);
                                    const totalTimeMs = refresh.total_time_seconds * 1000;
                                    const percentage = timeValue && totalTimeMs > 0 
                                        ? ((timeValue / totalTimeMs) * 100).toFixed(1) 
                                        : '0.0';
                                    
                                    const refreshIdShort = refresh.refresh_id ? refresh.refresh_id.substring(0, 8) + '...' : 'N/A';
                                    
                                    return `
                                        <tr onclick="openLogViewer(${refresh.line_number})">
                                            <td>
                                                <a href="javascript:void(0)" 
                                                   style="color: #667eea; font-weight: 600; text-decoration: none;"
                                                   onclick="event.stopPropagation(); openLogViewer(${refresh.line_number});"
                                                   title="Jump to line ${refresh.line_number} in log">
                                                    ${refresh.line_number}
                                                </a>
                                            </td>
                                            <td>
                                                <span class="mono" title="${refresh.refresh_id || 'N/A'}">${refreshIdShort}</span>
                                            </td>
                                            <td>
                                                <strong style="color: #1a1a1a; font-size: 1.05em;">${timeFormatted}</strong>
                                            </td>
                                            <td>
                                                <span class="badge ${parseFloat(percentage) > 50 ? 'badge-warning' : ''}" 
                                                      style="font-weight: 600;">
                                                    ${percentage}%
                                                </span>
                                            </td>
                                            <td>
                                                <span style="color: #666; font-weight: 500;">${totalTime}</span>
                                            </td>
                                            <td>
                                                <span style="font-size: 0.9em; color: #555;">${refresh.initiated_by || 'N/A'}</span>
                                            </td>
                                            <td>
                                                <span class="badge">
                                                    ${refresh.imports_actual || 0} / ${refresh.imports_total || 0}
                                                </span>
                                            </td>
                                            <td style="font-size: 0.85em; color: #666;">
                                                ${refresh.domain_reloads ? `<span class="badge badge-warning">${refresh.domain_reloads} reloads</span>` : ''}
                                                ${refresh.compile_time_ms ? `<span class="badge" style="margin-left: 5px;">Compile: ${formatTime(refresh.compile_time_ms / 1000)}</span>` : ''}
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #667eea;">
                        <strong style="color: #667eea;">‚ÑπÔ∏è Understanding Pipeline Refresh Breakdown:</strong>
                        <ul style="margin-top: 10px; padding-left: 20px; color: #555;">
                            <li><strong>Asset DB Processing:</strong> Time spent processing asset database</li>
                            <li><strong>Asset DB Callbacks:</strong> Time in callback functions during import</li>
                            <li><strong>Script Compilation:</strong> Time compiling C# scripts (usually the largest)</li>
                            <li><strong>Domain Reloads:</strong> Time reloading the scripting domain</li>
                            <li><strong>Other Scripting:</strong> Other script-related operations</li>
                        </ul>
                        <p style="margin-top: 10px; color: #666; font-size: 0.95em;">
                            <strong>Note:</strong> These times run mostly in parallel with asset imports. 
                            Total pipeline time ‚â† sum of all parts.
                        </p>
                    </div>
                </div>
            `;
            
            // Auto-scroll to tables after a brief delay
            setTimeout(() => {
                tablesDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
        }
        
        let allAssetsData = [];
        let displayedAssetCount = 100;
        const assetPageSize = 100;
        
        async function displayAssetsTable(assets, title) {
            const tablesDiv = document.getElementById('tables');
            
            allAssetsData = assets;
            displayedAssetCount = Math.min(assetPageSize, assets.length);
            
            const totalTime = assets.reduce((sum, a) => sum + a.import_time_ms, 0);
            
            // Get project load time for percentage calculation
            let projectLoadTimeSeconds = 0;
            try {
                const summaryResponse = await fetch(`/api/log/${currentLogId}/summary`);
                const summary = await summaryResponse.json();
                projectLoadTimeSeconds = summary.project_load_time_seconds || 0;
            } catch (error) {
                console.error('Failed to get project load time:', error);
            }
            
            const percentageOfLoad = projectLoadTimeSeconds > 0 
                ? ((totalTime / 1000 / projectLoadTimeSeconds) * 100).toFixed(1)
                : 'N/A';
            
            // Check if we're coming from std dev view and add back button
            const backButtonHtml = stdDevViewState ? `
                <div style="margin-bottom: 15px;">
                    <button onclick="restoreStdDevView()" style="
                        padding: 8px 16px;
                        background: #667eea;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 0.9em;
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                    ">
                        ‚Üê Back to Histogram
                    </button>
                </div>
            ` : '';
            
            tablesDiv.innerHTML = `
                <div class="table-container">
                    ${backButtonHtml}
                    <h2>${title}</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div class="stat-card" style="margin: 0;">
                            <div class="stat-label">Asset Count</div>
                            <div class="stat-value">${assets.length.toLocaleString()}</div>
                        </div>
                        <div class="stat-card" style="margin: 0;">
                            <div class="stat-label">Total Time</div>
                            <div class="stat-value">${formatTime(totalTime / 1000)}</div>
                        </div>
                        <div class="stat-card" style="margin: 0;">
                            <div class="stat-label">% of Full Load Time</div>
                            <div class="stat-value">${percentageOfLoad}${percentageOfLoad !== 'N/A' ? '%' : ''}</div>
                        </div>
                    </div>
                    <p style="margin-bottom: 15px; color: #666;">
                        üí° <strong>Click</strong> any row or line number to jump to that location in the log
                    </p>
                    <div style="max-height: 600px; overflow-y: auto; overflow-x: hidden;" id="asset-table-scroll">
                        <table>
                            <thead style="position: sticky; top: 0; background: white; z-index: 10;">
                                <tr>
                                    <th style="width: 70px;">Line #</th>
                                    <th style="min-width: 250px;">Asset Name</th>
                                    <th style="width: 120px;">Category</th>
                                    <th style="width: 100px;">Type</th>
                                    <th style="width: 110px;">Importer</th>
                                    <th style="width: 100px; text-align: right;">Time</th>
                                    <th style="min-width: 250px;">Path</th>
                                </tr>
                            </thead>
                            <tbody id="asset-table-body">
                            </tbody>
                        </table>
                    </div>
                    <div id="asset-load-indicator" style="text-align: center; padding: 15px; color: #667eea; display: none;">
                        Loading more assets...
                    </div>
                    <div id="asset-info" style="text-align: center; padding: 10px; color: #999; font-size: 0.9em;">
                        Showing ${displayedAssetCount} of ${assets.length} assets
                    </div>
                </div>
            `;
            
            renderAssetRows();
            setupAssetTableScroll();
            setupAssetTableContextMenus();
            
            // Auto-scroll to tables after a brief delay to ensure rendering
            setTimeout(() => {
                tablesDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
        }
        
        function setupAssetTableContextMenus() {
            const tbody = document.getElementById('asset-table-body');
            if (!tbody) return;
            
            const rows = tbody.querySelectorAll('tr[data-path]');
            rows.forEach(row => {
                const path = row.getAttribute('data-path');
                if (!path) return;
                const decodedPath = path.replace(/&quot;/g, '"');
                
                row.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    showContextMenu(e, decodedPath);
                });
            });
        }
        
        function renderAssetRows() {
            const tbody = document.getElementById('asset-table-body');
            const assetsToShow = allAssetsData.slice(0, displayedAssetCount);
            
            tbody.innerHTML = assetsToShow.map(asset => {
                const category = asset.asset_category || 'Unknown';
                const importer = asset.importer_type || 'Unknown';
                const timeSeconds = asset.import_time_ms / 1000;
                const timeFormatted = formatTime(timeSeconds);
                
                // Determine badge color based on time
                let timeBadgeClass = 'badge';
                if (timeSeconds > 1) {
                    timeBadgeClass = 'badge-warning';
                } else if (timeSeconds < 0.1) {
                    timeBadgeClass = 'badge-success';
                }
                
                const assetPath = asset.asset_path || '';
                const escapedPath = assetPath.replace(/"/g, '&quot;');
                
                return `
                <tr data-line="${asset.line_number}" 
                    data-path="${escapedPath}"
                    onclick="openLogViewer(${asset.line_number})">
                    <td style="font-size: 0.85em;">
                        <a href="javascript:void(0)" 
                           style="color: #667eea; font-weight: 600; text-decoration: none;"
                           onclick="event.stopPropagation(); openLogViewer(${asset.line_number});"
                           title="Jump to line ${asset.line_number} in log">
                            ${asset.line_number}
                        </a>
                    </td>
                    <td>
                        <strong style="color: #1a1a1a; font-size: 0.9em; word-break: break-word;">${asset.asset_name}</strong>
                    </td>
                    <td>
                        <span class="badge">${category}</span>
                    </td>
                    <td>
                        <span class="mono">${asset.asset_type || 'N/A'}</span>
                    </td>
                    <td>
                        <span class="mono" style="font-size: 0.85em;">${importer}</span>
                    </td>
                    <td style="text-align: right;">
                        <span class="${timeBadgeClass}" style="font-weight: 600;">${timeFormatted}</span>
                    </td>
                    <td>
                        <span class="text-truncate-long" 
                              style="font-size: 0.9em; color: #666;">
                            ${asset.asset_path}
                        </span>
                    </td>
                </tr>
            `;
            }).join('');
            
            // Update info
            const infoDiv = document.getElementById('asset-info');
            if (infoDiv) {
                if (displayedAssetCount >= allAssetsData.length) {
                    infoDiv.textContent = `Showing all ${allAssetsData.length} assets`;
                } else {
                    infoDiv.textContent = `Showing ${displayedAssetCount} of ${allAssetsData.length} assets (scroll to load more)`;
                }
            }
        }
        
        function setupAssetTableScroll() {
            const scrollContainer = document.getElementById('asset-table-scroll');
            if (!scrollContainer) return;
            
            let isLoadingAssets = false;
            
            scrollContainer.addEventListener('scroll', () => {
                const scrollTop = scrollContainer.scrollTop;
                const scrollHeight = scrollContainer.scrollHeight;
                const clientHeight = scrollContainer.clientHeight;
                
                // Load more when within 100px of bottom
                if (scrollTop + clientHeight > scrollHeight - 100 && !isLoadingAssets && displayedAssetCount < allAssetsData.length) {
                    isLoadingAssets = true;
                    document.getElementById('asset-load-indicator').style.display = 'block';
                    
                    setTimeout(() => {
                        displayedAssetCount = Math.min(displayedAssetCount + assetPageSize, allAssetsData.length);
                        renderAssetRows();
                        setupAssetTableContextMenus();
                        isLoadingAssets = false;
                        document.getElementById('asset-load-indicator').style.display = 'none';
                    }, 100);
                }
            });
        }
        
        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            
            if (currentView === 'overview') {
                breadcrumb.innerHTML = '';
            } else if (currentView === 'pipeline') {
                breadcrumb.innerHTML = `
                    <a href="#" onclick="loadOverview(); return false;">Overview</a>
                    <span>‚Üí Pipeline Refresh: ${currentFilter}</span>
                `;
            } else if (currentView === 'all_assets') {
                breadcrumb.innerHTML = `
                    <a href="#" onclick="loadOverview(); return false;">Overview</a>
                    <span>‚Üí All Assets</span>
                `;
            } else if (currentView === 'folder_analysis') {
                breadcrumb.innerHTML = `
                    <a href="#" onclick="loadOverview(); return false;">Overview</a>
                    <span>‚Üí Folder Analysis</span>
                `;
            } else {
                breadcrumb.innerHTML = `
                    <a href="#" onclick="loadOverview(); return false;">Overview</a>
                    <span>‚Üí ${currentFilter}</span>
                `;
            }
        }
        
        function showLoading(message = 'Loading data') {
            const loadingDiv = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            loadingText.textContent = message;
            loadingDiv.style.display = 'block';
        }
        
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }
        
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            hideLoading();
        }
        
        function hideError() {
            const errorDiv = document.getElementById('error');
            errorDiv.style.display = 'none';
        }
        
        async function copySlackHeadlines() {
            const btn = document.getElementById('slack-copy-btn');
            const originalText = btn.textContent;
            
            try {
                btn.textContent = 'Loading...';
                btn.disabled = true;
                
                // Fetch all required data
                const [summaryRes, assetsRes, timelineRes] = await Promise.all([
                    fetch(`/api/log/${currentLogId}/summary`),
                    fetch(`/api/log/${currentLogId}/assets`),
                    fetch(`/api/log/${currentLogId}/timeline`)
                ]);
                
                const summary = await summaryRes.json();
                const assets = await assetsRes.json();
                const timeline = await timelineRes.json();
                
                // Build Slack-formatted text
                let slackText = '*Unity Project Load Analysis*\n\n';
                
                // Total load time
                const totalTime = summary.project_load_time_seconds || 0;
                slackText += `*Total Load Time:* ${formatTime(totalTime)}\n\n`;
                
                // Top 3 import time categories
                const topCategories = (summary.by_category || []).slice(0, 3);
                if (topCategories.length > 0) {
                    slackText += '*Top 3 Import Time Categories:*\n';
                    topCategories.forEach((cat, idx) => {
                        slackText += `${idx + 1}. *${cat.asset_category}*: ${formatTime((cat.total_time || 0) / 1000)}\n`;
                    });
                    slackText += '\n';
                }
                
                // Top 3 worst files
                const topWorst = assets
                    .sort((a, b) => b.import_time_ms - a.import_time_ms)
                    .slice(0, 3);
                if (topWorst.length > 0) {
                    slackText += '*Top 3 Slowest Assets:*\n';
                    topWorst.forEach((asset, idx) => {
                        const timeSeconds = asset.import_time_ms / 1000;
                        const assetName = asset.asset_name || asset.asset_path.split('/').pop() || 'Unknown';
                        slackText += `${idx + 1}. *${assetName}* (${asset.asset_type || 'N/A'}): ${formatTime(timeSeconds)}\n`;
                    });
                    slackText += '\n';
                }
                
                // Script compilation time
                const scriptCompTime = timeline.summary?.script_compilation_time_ms || 0;
                if (scriptCompTime > 0) {
                    slackText += `*Script Compilation Time:* ${formatTime(scriptCompTime / 1000)}\n`;
                } else {
                    slackText += `*Script Compilation Time:* N/A\n`;
                }
                
                // Copy to clipboard
                await navigator.clipboard.writeText(slackText);
                
                // Show success feedback
                btn.textContent = '‚úì Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
            } catch (error) {
                console.error('Failed to copy Slack headlines:', error);
                btn.textContent = 'Error';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
            }
        }
        
        // Log Viewer Overlay Functions
        function openLogViewer(lineNumber) {
            const overlay = document.getElementById('log-viewer-overlay');
            const panel = document.getElementById('log-viewer-panel');
            
            if (!overlay || !panel) {
                // Fallback to full page navigation
                window.location.href = `/log-viewer?line=${lineNumber}`;
                return;
            }
            
            overlay.classList.add('active');
            panel.classList.add('active');
            
            // Prevent body scroll when overlay is open
            document.body.style.overflow = 'hidden';
            
            // Load log content
            loadLogViewerContent(lineNumber);
        }
        
        function openLogViewerWithFilter(filter) {
            window.location.href = `/log-viewer?filter=${encodeURIComponent(filter)}`;
        }
        
        function closeLogViewer() {
            const overlay = document.getElementById('log-viewer-overlay');
            const panel = document.getElementById('log-viewer-panel');
            
            if (overlay) overlay.classList.remove('active');
            if (panel) panel.classList.remove('active');
            
            // Restore body scroll
            document.body.style.overflow = '';
        }
        
        // Keyboard support: ESC to close
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const overlay = document.getElementById('log-viewer-overlay');
                if (overlay && overlay.classList.contains('active')) {
                    closeLogViewer();
                }
            }
        });
        
        async function loadLogViewerContent(lineNumber) {
            const content = document.getElementById('log-viewer-content');
            const loading = document.getElementById('log-viewer-loading');
            const stats = document.getElementById('log-viewer-stats');
            
            if (!content || !currentLogId) return;
            
            // Show loading
            if (loading) loading.style.display = 'block';
            if (content) content.innerHTML = '';
            
            try {
                const url = `/api/log/${currentLogId}/log-viewer?line=${lineNumber}`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.lines && data.lines.length > 0) {
                    renderLogLines(data.lines, lineNumber);
                    
                    // Update stats
                    if (stats) {
                        stats.innerHTML = `
                            <span>Total lines: ${data.total_lines || 0}</span>
                            <span>Showing: ${data.lines.length} lines (around line ${lineNumber})</span>
                        `;
                    }
                } else {
                    if (content) content.innerHTML = '<div style="color: #858585; text-align: center; padding: 50px;">No log content available</div>';
                }
            } catch (error) {
                console.error('Failed to load log content:', error);
                if (content) content.innerHTML = '<div style="color: #f48771; text-align: center; padding: 50px;">Failed to load log content</div>';
            } finally {
                if (loading) loading.style.display = 'none';
            }
        }
        
        function renderLogLines(lines, highlightLine) {
            const content = document.getElementById('log-viewer-content');
            if (!content) return;
            
            content.innerHTML = lines.map(line => {
                const lineClasses = ['log-viewer-line'];
                if (line.is_error) lineClasses.push('error');
                if (line.is_warning) lineClasses.push('warning');
                if (line.line_type) lineClasses.push(line.line_type);
                if (line.indent_level) lineClasses.push(`indent-${Math.min(line.indent_level, 5)}`);
                if (line.line_number == highlightLine) lineClasses.push('highlighted');
                
                const timestamp = line.timestamp ? `<span class="timestamp">${line.timestamp}</span>` : '';
                
                return `
                    <div class="${lineClasses.join(' ')}" data-line="${line.line_number}">
                        <span class="log-viewer-line-number">${line.line_number}</span>
                        <span class="log-viewer-line-content">${timestamp}${escapeHtml(line.content || '')}</span>
                    </div>
                `;
            }).join('');
            
            // Scroll to highlighted line
            if (highlightLine) {
                setTimeout(() => {
                    const highlighted = content.querySelector(`[data-line="${highlightLine}"]`);
                    if (highlighted) {
                        highlighted.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Update navigateToLogLine to use overlay
        function navigateToLogLine(lineNumber) {
            if (lineNumber && lineNumber > 0) {
                openLogViewer(lineNumber);
            } else {
                console.warn('No line number available for this timeline segment');
            }
        }
    </script>
    
    <!-- Log Viewer Overlay -->
    <div id="log-viewer-overlay" class="log-viewer-overlay" onclick="if(event.target === this) closeLogViewer();">
        <div id="log-viewer-panel" class="log-viewer-panel">
            <div class="log-viewer-header">
                <h2>üìÑ Log Viewer</h2>
                <button class="log-viewer-close" onclick="closeLogViewer();" title="Close">√ó</button>
            </div>
            <div class="log-viewer-controls">
                <div class="log-viewer-search">
                    <input type="text" id="log-viewer-search" placeholder="Search log... (press Enter)" onkeypress="if(event.key === 'Enter') searchLogViewer(event.target.value);">
                </div>
                <div class="log-viewer-filters">
                    <button class="log-viewer-filter-btn active" data-filter="all" onclick="filterLogViewer('all')">All</button>
                    <button class="log-viewer-filter-btn" data-filter="error" onclick="filterLogViewer('error')">Errors</button>
                    <button class="log-viewer-filter-btn" data-filter="warning" onclick="filterLogViewer('warning')">Warnings</button>
                    <button class="log-viewer-filter-btn" data-filter="import" onclick="filterLogViewer('import')">Imports</button>
                    <button class="log-viewer-filter-btn" data-filter="pipeline" onclick="filterLogViewer('pipeline')">Pipeline</button>
                </div>
            </div>
            <div id="log-viewer-loading" class="log-viewer-loading" style="display: none;">Loading log...</div>
            <div id="log-viewer-content" class="log-viewer-content"></div>
            <div id="log-viewer-stats" class="log-viewer-stats">
                <span>Total lines: 0</span>
                <span>Showing: 0 lines</span>
            </div>
        </div>
    </div>
</body>
</html>
